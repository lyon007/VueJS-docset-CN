import{_ as a,c as n,b as l,o as p}from"./chunks/framework.B2oIMGqn.js";const F=JSON.parse('{"title":"响应式 API：工具函数","description":"","frontmatter":{},"headers":[{"level":2,"title":"isRef()","slug":"isref","link":"#isref","children":[]},{"level":2,"title":"unref()","slug":"unref","link":"#unref","children":[]},{"level":2,"title":"toRef()","slug":"toref","link":"#toref","children":[]},{"level":2,"title":"toValue()","slug":"tovalue","link":"#tovalue","children":[]},{"level":2,"title":"toRefs()","slug":"torefs","link":"#torefs","children":[]},{"level":2,"title":"isProxy()","slug":"isproxy","link":"#isproxy","children":[]},{"level":2,"title":"isReactive()","slug":"isreactive","link":"#isreactive","children":[]},{"level":2,"title":"isReadonly()","slug":"isreadonly","link":"#isreadonly","children":[]}],"relativePath":"api/reactivity-utilities.md","filePath":"api/reactivity-utilities.md"}'),o={name:"api/reactivity-utilities.md"};function e(t,s,c,r,y,i){return p(),n("div",null,s[0]||(s[0]=[l(`<h1 id="reactivity-api-utilities" tabindex="-1">响应式 API：工具函数 <a class="header-anchor" href="#reactivity-api-utilities" aria-label="Permalink to &quot;响应式 API：工具函数 {#reactivity-api-utilities}&quot;">​</a></h1><h2 id="isref" tabindex="-1">isRef() <a class="header-anchor" href="#isref" aria-label="Permalink to &quot;isRef() {#isref}&quot;">​</a></h2><p>检查某个值是否为 ref。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> isRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">r</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">|</span><span style="color:#79B8FF;"> unknown</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#FFAB70;"> r</span><span style="color:#F97583;"> is</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>请注意，返回值是一个<a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" target="_blank" rel="noreferrer">类型判定</a> (type predicate)，这意味着 <code>isRef</code> 可以被用作类型守卫：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> foo</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> unknown</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">isRef</span><span style="color:#E1E4E8;">(foo)) {</span></span>
<span class="line"><span style="color:#6A737D;">  // foo 的类型被收窄为了 Ref&lt;unknown&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  foo.value</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li></ul><h2 id="unref" tabindex="-1">unref() <a class="header-anchor" href="#unref" aria-label="Permalink to &quot;unref() {#unref}&quot;">​</a></h2><p>如果参数是 ref，则返回内部值，否则返回参数本身。这是 <code>val = isRef(val) ? val.value : val</code> 计算的一个语法糖。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> unref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">ref</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> |</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span></code></pre></div></li><li><p><strong>示例</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> useFoo</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">x</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#F97583;"> |</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> unwrapped</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> unref</span><span style="color:#E1E4E8;">(x)</span></span>
<span class="line"><span style="color:#6A737D;">  // unwrapped 现在保证为 number 类型</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li></ul><h2 id="toref" tabindex="-1">toRef() <a class="header-anchor" href="#toref" aria-label="Permalink to &quot;toRef() {#toref}&quot;">​</a></h2><p>可以将值、refs 或 getters 规范化为 refs (3.3+)。</p><p>也可以基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 规范化签名 (3.3+)</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> toRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="color:#FFAB70;">  value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> extends</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#F97583;"> infer</span><span style="color:#B392F0;"> R</span></span>
<span class="line"><span style="color:#F97583;">  ?</span><span style="color:#B392F0;"> Readonly</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">R</span><span style="color:#E1E4E8;">&gt;&gt;</span></span>
<span class="line"><span style="color:#F97583;">  :</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> extends</span><span style="color:#B392F0;"> Ref</span></span>
<span class="line"><span style="color:#F97583;">  ?</span><span style="color:#B392F0;"> T</span></span>
<span class="line"><span style="color:#F97583;">  :</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">UnwrapRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 对象属性签名</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> toRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#F97583;"> extends</span><span style="color:#79B8FF;"> object</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">K</span><span style="color:#F97583;"> extends</span><span style="color:#F97583;"> keyof</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="color:#FFAB70;">  object</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#FFAB70;">  key</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> K</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#FFAB70;">  defaultValue</span><span style="color:#F97583;">?:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">[</span><span style="color:#B392F0;">K</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> ToRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">[</span><span style="color:#B392F0;">K</span><span style="color:#E1E4E8;">]&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> ToRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> extends</span><span style="color:#B392F0;"> Ref</span><span style="color:#F97583;"> ?</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> :</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>示例</strong></p><p>规范化签名 (3.3+)：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 按原样返回现有的 ref</span></span>
<span class="line"><span style="color:#B392F0;">toRef</span><span style="color:#E1E4E8;">(existingRef)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 创建一个只读的 ref，当访问 .value 时会调用此 getter 函数</span></span>
<span class="line"><span style="color:#B392F0;">toRef</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> props.foo)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 从非函数的值中创建普通的 ref</span></span>
<span class="line"><span style="color:#6A737D;">// 等同于 ref(1)</span></span>
<span class="line"><span style="color:#B392F0;">toRef</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span></code></pre></div><p>对象属性签名：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> state</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  foo: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  bar: </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 双向 ref，会与源属性同步</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> fooRef</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> toRef</span><span style="color:#E1E4E8;">(state, </span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 更改该 ref 会更新源属性</span></span>
<span class="line"><span style="color:#E1E4E8;">fooRef.value</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(state.foo) </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 更改源属性也会更新该 ref</span></span>
<span class="line"><span style="color:#E1E4E8;">state.foo</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(fooRef.value) </span><span style="color:#6A737D;">// 3</span></span></code></pre></div><p>请注意，这不同于：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> fooRef</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(state.foo)</span></span></code></pre></div><p>上面这个 ref <strong>不会</strong>和 <code>state.foo</code> 保持同步，因为这个 <code>ref()</code> 接收到的是一个纯数值。</p><p><code>toRef()</code> 这个函数在你想把一个 prop 的 ref 传递给一个组合式函数时会很有用：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#B392F0;"> setup</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { toRef } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> props</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> defineProps</span><span style="color:#E1E4E8;">(</span><span style="color:#6A737D;">/* ... */</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 将 \`props.foo\` 转换为 ref，然后传入</span></span>
<span class="line"><span style="color:#6A737D;">// 一个组合式函数</span></span>
<span class="line"><span style="color:#B392F0;">useSomeFeature</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">toRef</span><span style="color:#E1E4E8;">(props, </span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// getter 语法——推荐在 3.3+ 版本使用</span></span>
<span class="line"><span style="color:#B392F0;">useSomeFeature</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">toRef</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> props.foo))</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>当 <code>toRef</code> 与组件 props 结合使用时，关于禁止对 props 做出更改的限制依然有效。尝试将新的值传递给 ref 等效于尝试直接更改 props，这是不允许的。在这种场景下，你可能可以考虑使用带有 <code>get</code> 和 <code>set</code> 的 <a href="./reactivity-core.html#computed"><code>computed</code></a> 替代。详情请见<a href="/guide/components/v-model.html">在组件上使用 <code>v-model</code></a> 指南。</p><p>当使用对象属性签名时，即使源属性当前不存在，<code>toRef()</code> 也会返回一个可用的 ref。这让它在处理可选 props 的时候格外实用，相比之下 <a href="#torefs"><code>toRefs</code></a> 就不会为可选 props 创建对应的 refs。</p></li></ul><h2 id="tovalue" tabindex="-1">toValue() <a class="header-anchor" href="#tovalue" aria-label="Permalink to &quot;toValue() {#tovalue}&quot;">​</a></h2><ul><li>仅在 3.3+ 中支持</li></ul><p>将值、refs 或 getters 规范化为值。这与 <a href="#unref">unref()</a> 类似，不同的是此函数也会规范化 getter 函数。如果参数是一个 getter，它将会被调用并且返回它的返回值。</p><p>这可以在<a href="/guide/reusability/composables.html">组合式函数</a>中使用，用来规范化一个可以是值、ref 或 getter 的参数。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> toValue</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">source</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> |</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> (() </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">))</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span></code></pre></div></li><li><p><strong>示例</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">toValue</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">//       --&gt; 1</span></span>
<span class="line"><span style="color:#B392F0;">toValue</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)) </span><span style="color:#6A737D;">//  --&gt; 1</span></span>
<span class="line"><span style="color:#B392F0;">toValue</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// --&gt; 1</span></span></code></pre></div><p>在组合式函数中规范化参数：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#F97583;"> type</span><span style="color:#E1E4E8;"> { MaybeRefOrGetter } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> useFeature</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">id</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> MaybeRefOrGetter</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="color:#B392F0;">  watch</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> toValue</span><span style="color:#E1E4E8;">(id), </span><span style="color:#FFAB70;">id</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">    // 处理 id 变更</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 这个组合式函数支持以下的任意形式：</span></span>
<span class="line"><span style="color:#B392F0;">useFeature</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#B392F0;">useFeature</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">))</span></span>
<span class="line"><span style="color:#B392F0;">useFeature</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">)</span></span></code></pre></div></li></ul><h2 id="torefs" tabindex="-1">toRefs() <a class="header-anchor" href="#torefs" aria-label="Permalink to &quot;toRefs() {#torefs}&quot;">​</a></h2><p>将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 <a href="#toref"><code>toRef()</code></a> 创建的。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> toRefs</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#F97583;"> extends</span><span style="color:#79B8FF;"> object</span><span style="color:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="color:#FFAB70;">  object</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  [</span><span style="color:#B392F0;">K</span><span style="color:#F97583;"> in</span><span style="color:#F97583;"> keyof</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">]</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> ToRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">[</span><span style="color:#B392F0;">K</span><span style="color:#E1E4E8;">]&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> ToRef</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> extends</span><span style="color:#B392F0;"> Ref</span><span style="color:#F97583;"> ?</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> :</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>示例</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> state</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  foo: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  bar: </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> stateAsRefs</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> toRefs</span><span style="color:#E1E4E8;">(state)</span></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;">stateAsRefs 的类型：{</span></span>
<span class="line"><span style="color:#6A737D;">  foo: Ref&lt;number&gt;,</span></span>
<span class="line"><span style="color:#6A737D;">  bar: Ref&lt;number&gt;</span></span>
<span class="line"><span style="color:#6A737D;">}</span></span>
<span class="line"><span style="color:#6A737D;">*/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 这个 ref 和源属性已经“链接上了”</span></span>
<span class="line"><span style="color:#E1E4E8;">state.foo</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(stateAsRefs.foo.value) </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">stateAsRefs.foo.value</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(state.foo) </span><span style="color:#6A737D;">// 3</span></span></code></pre></div><p>当从组合式函数中返回响应式对象时，<code>toRefs</code> 相当有用。使用它，消费者组件可以解构/展开返回的对象而不会失去响应性：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> useFeatureX</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> state</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    foo: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    bar: </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // ...基于状态的操作逻辑</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 在返回时都转为 ref</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#B392F0;"> toRefs</span><span style="color:#E1E4E8;">(state)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 可以解构而不会失去响应性</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">foo</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">bar</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> useFeatureX</span><span style="color:#E1E4E8;">()</span></span></code></pre></div><p><code>toRefs</code> 在调用时只会为源对象上可以枚举的属性创建 ref。如果要为可能还不存在的属性创建 ref，请改用 <a href="#toref"><code>toRef</code></a>。</p></li></ul><h2 id="isproxy" tabindex="-1">isProxy() <a class="header-anchor" href="#isproxy" aria-label="Permalink to &quot;isProxy() {#isproxy}&quot;">​</a></h2><p>检查一个对象是否是由 <a href="./reactivity-core.html#reactive"><code>reactive()</code></a>、<a href="./reactivity-core.html#readonly"><code>readonly()</code></a>、<a href="./reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> 或 <a href="./reactivity-advanced.html#shallowreadonly"><code>shallowReadonly()</code></a> 创建的代理。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> isProxy</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> any</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> boolean</span></span></code></pre></div></li></ul><h2 id="isreactive" tabindex="-1">isReactive() <a class="header-anchor" href="#isreactive" aria-label="Permalink to &quot;isReactive() {#isreactive}&quot;">​</a></h2><p>检查一个对象是否是由 <a href="./reactivity-core.html#reactive"><code>reactive()</code></a> 或 <a href="./reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> 创建的代理。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> isReactive</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> unknown</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> boolean</span></span></code></pre></div></li></ul><h2 id="isreadonly" tabindex="-1">isReadonly() <a class="header-anchor" href="#isreadonly" aria-label="Permalink to &quot;isReadonly() {#isreadonly}&quot;">​</a></h2><p>检查传入的值是否为只读对象。只读对象的属性可以更改，但他们不能通过传入的对象直接赋值。</p><p>通过 <a href="./reactivity-core.html#readonly"><code>readonly()</code></a> 和 <a href="./reactivity-advanced.html#shallowreadonly"><code>shallowReadonly()</code></a> 创建的代理都是只读的，类似于没有 <code>set</code> 函数的 <a href="./reactivity-core.html#computed"><code>computed()</code></a> ref。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> isReadonly</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> unknown</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> boolean</span></span></code></pre></div></li></ul>`,29)]))}const d=a(o,[["render",e]]);export{F as __pageData,d as default};
