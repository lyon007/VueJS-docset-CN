import{_ as a,c as n,b as l,o as p}from"./chunks/framework.B2oIMGqn.js";const F=JSON.parse('{"title":"响应式 API：核心","description":"","frontmatter":{},"headers":[{"level":2,"title":"ref()","slug":"ref","link":"#ref","children":[]},{"level":2,"title":"computed()","slug":"computed","link":"#computed","children":[]},{"level":2,"title":"reactive()","slug":"reactive","link":"#reactive","children":[]},{"level":2,"title":"readonly()","slug":"readonly","link":"#readonly","children":[]},{"level":2,"title":"watchEffect()","slug":"watcheffect","link":"#watcheffect","children":[]},{"level":2,"title":"watchPostEffect()","slug":"watchposteffect","link":"#watchposteffect","children":[]},{"level":2,"title":"watchSyncEffect()","slug":"watchsynceffect","link":"#watchsynceffect","children":[]},{"level":2,"title":"watch()","slug":"watch","link":"#watch","children":[]},{"level":2,"title":"onWatcherCleanup()","slug":"onwatchercleanup","link":"#onwatchercleanup","children":[]}],"relativePath":"api/reactivity-core.md","filePath":"api/reactivity-core.md"}'),o={name:"api/reactivity-core.md"};function e(c,s,t,r,y,E){return p(),n("div",null,s[0]||(s[0]=[l(`<h1 id="reactivity-api-core" tabindex="-1">响应式 API：核心 <a class="header-anchor" href="#reactivity-api-core" aria-label="Permalink to &quot;响应式 API：核心 {#reactivity-api-core}&quot;">​</a></h1><div class="info custom-block"><p class="custom-block-title">参考</p><p>要更好地了解响应式 API，推荐阅读下面几个指南中的章节：</p><ul><li><a href="/guide/essentials/reactivity-fundamentals.html">响应式基础</a> (with the API preference set to Composition API)</li><li><a href="/guide/extras/reactivity-in-depth.html">深入响应式系统</a></li></ul></div><h2 id="ref" tabindex="-1">ref() <a class="header-anchor" href="#ref" aria-label="Permalink to &quot;ref() {#ref}&quot;">​</a></h2><p>接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 <code>.value</code>。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">UnwrapRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">interface</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#FFAB70;">  value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>详细信息</strong></p><p>ref 对象是可更改的，也就是说你可以为 <code>.value</code> 赋予新的值。它也是响应式的，即所有对 <code>.value</code> 的操作都将被追踪，并且写操作会触发与之相关的副作用。</p><p>如果将一个对象赋值给 ref，那么这个对象将通过 <a href="#reactive">reactive()</a> 转为具有深层次响应式的对象。这也意味着如果对象中包含了嵌套的 ref，它们将被深层地解包。</p><p>若要避免这种深层次的转换，请使用 <a href="./reactivity-advanced.html#shallowref"><code>shallowRef()</code></a> 来替代。</p></li><li><p><strong>示例</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> count</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(count.value) </span><span style="color:#6A737D;">// 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">count.value </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 1</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(count.value) </span><span style="color:#6A737D;">// 1</span></span></code></pre></div></li><li><p><strong>参考</strong></p><ul><li><a href="/guide/essentials/reactivity-fundamentals.html#reactive-variables-with-ref">指南 - <code>ref()</code> 的响应式基础</a></li><li><a href="/guide/typescript/composition-api.html#typing-ref">指南 - 为 <code>ref()</code> 标注类型</a> <sup class="vt-badge ts"></sup></li></ul></li></ul><h2 id="computed" tabindex="-1">computed() <a class="header-anchor" href="#computed" aria-label="Permalink to &quot;computed() {#computed}&quot;">​</a></h2><p>接受一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description" target="_blank" rel="noreferrer">getter 函数</a>，返回一个只读的响应式 <a href="#ref">ref</a> 对象。该 ref 通过 <code>.value</code> 暴露 getter 函数的返回值。它也可以接受一个带有 <code>get</code> 和 <code>set</code> 函数的对象来创建一个可写的 ref 对象。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 只读</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> computed</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="color:#B392F0;">  getter</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">oldValue</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> |</span><span style="color:#79B8FF;"> undefined</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#6A737D;">  // 查看下方的 &quot;计算属性调试&quot; 链接</span></span>
<span class="line"><span style="color:#FFAB70;">  debuggerOptions</span><span style="color:#F97583;">?:</span><span style="color:#B392F0;"> DebuggerOptions</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Readonly</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">Readonly</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;&gt;&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 可写的</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> computed</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="color:#FFAB70;">  options</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#B392F0;">    get</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">oldValue</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> |</span><span style="color:#79B8FF;"> undefined</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> T</span></span>
<span class="line"><span style="color:#B392F0;">    set</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#FFAB70;">  debuggerOptions</span><span style="color:#F97583;">?:</span><span style="color:#B392F0;"> DebuggerOptions</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>示例</strong></p><p>创建一个只读的计算属性 ref：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> count</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> plusOne</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> computed</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> count.value </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(plusOne.value) </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">plusOne.value</span><span style="color:#F97583;">++</span><span style="color:#6A737D;"> // 错误</span></span></code></pre></div><p>创建一个可写的计算属性 ref：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> count</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> plusOne</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> computed</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#B392F0;">  get</span><span style="color:#E1E4E8;">: () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> count.value </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#B392F0;">  set</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">val</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    count.value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> val </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">plusOne.value </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 1</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(count.value) </span><span style="color:#6A737D;">// 0</span></span></code></pre></div><p>调试：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> plusOne</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> computed</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> count.value </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#B392F0;">  onTrack</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    debugger</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#B392F0;">  onTrigger</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    debugger</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div></li><li><p><strong>参考</strong></p><ul><li><a href="/guide/essentials/computed.html">指南 - 计算属性</a></li><li><a href="/guide/extras/reactivity-in-depth.html#computed-debugging">指南 - 计算属性调试</a></li><li><a href="/guide/typescript/composition-api.html#typing-computed">指南 - 为 <code>computed()</code> 标注类型</a> <sup class="vt-badge ts"></sup></li><li><a href="/guide/best-practices/performance.html#computed-stability">指南 - 性能优化 - 计算属性稳定性</a></li></ul></li></ul><h2 id="reactive" tabindex="-1">reactive() <a class="header-anchor" href="#reactive" aria-label="Permalink to &quot;reactive() {#reactive}&quot;">​</a></h2><p>返回一个对象的响应式代理。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#F97583;"> extends</span><span style="color:#79B8FF;"> object</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">target</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> UnwrapNestedRefs</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>详细信息</strong></p><p>响应式转换是“深层”的：它会影响到所有嵌套的属性。一个响应式对象也将深层地解包任何 <a href="#ref">ref</a> 属性，同时保持响应性。</p><p>值得注意的是，当访问到某个响应式数组或 <code>Map</code> 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包。</p><p>若要避免深层响应式转换，只想保留对这个对象顶层次访问的响应性，请使用 <a href="./reactivity-advanced.html#shallowreactive">shallowReactive()</a> 作替代。</p><p>返回的对象以及其中嵌套的对象都会通过 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noreferrer">ES Proxy</a> 包裹，因此<strong>不等于</strong>源对象，建议只使用响应式代理，避免使用原始对象。</p></li><li><p><strong>示例</strong></p><p>创建一个响应式对象：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> obj</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({ count: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> })</span></span>
<span class="line"><span style="color:#E1E4E8;">obj.count</span><span style="color:#F97583;">++</span></span></code></pre></div><p>ref 的解包：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> count</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> obj</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({ count })</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// ref 会被解包</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(obj.count </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> count.value) </span><span style="color:#6A737D;">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 会更新 \`obj.count\`</span></span>
<span class="line"><span style="color:#E1E4E8;">count.value</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(count.value) </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(obj.count) </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 也会更新 \`count\` ref</span></span>
<span class="line"><span style="color:#E1E4E8;">obj.count</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(obj.count) </span><span style="color:#6A737D;">// 3</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(count.value) </span><span style="color:#6A737D;">// 3</span></span></code></pre></div><p>注意当访问到某个响应式数组或 <code>Map</code> 这样的原生集合类型中的 ref 元素时，<strong>不会</strong>执行 ref 的解包：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> books</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">([</span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Vue 3 Guide&#39;</span><span style="color:#E1E4E8;">)])</span></span>
<span class="line"><span style="color:#6A737D;">// 这里需要 .value</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(books[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">].value)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> map</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> Map</span><span style="color:#E1E4E8;">([[</span><span style="color:#9ECBFF;">&#39;count&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)]]))</span></span>
<span class="line"><span style="color:#6A737D;">// 这里需要 .value</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(map.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;count&#39;</span><span style="color:#E1E4E8;">).value)</span></span></code></pre></div><p>将一个 <a href="#ref">ref</a> 赋值给一个 <code>reactive</code> 属性时，该 ref 会被自动解包：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> count</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> obj</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">obj.count </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> count</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(obj.count) </span><span style="color:#6A737D;">// 1</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(obj.count </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> count.value) </span><span style="color:#6A737D;">// true</span></span></code></pre></div></li><li><p><strong>参考</strong></p><ul><li><a href="/guide/essentials/reactivity-fundamentals.html">指南 - 响应式基础</a></li><li><a href="/guide/typescript/composition-api.html#typing-reactive">指南 - 为 <code>reactive()</code> 标注类型</a> <sup class="vt-badge ts"></sup></li></ul></li></ul><h2 id="readonly" tabindex="-1">readonly() <a class="header-anchor" href="#readonly" aria-label="Permalink to &quot;readonly() {#readonly}&quot;">​</a></h2><p>接受一个对象 (不论是响应式还是普通的) 或是一个 <a href="#ref">ref</a>，返回一个原值的只读代理。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> readonly</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#F97583;"> extends</span><span style="color:#79B8FF;"> object</span><span style="color:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="color:#FFAB70;">  target</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> DeepReadonly</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">UnwrapNestedRefs</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;&gt;</span></span></code></pre></div></li><li><p><strong>详细信息</strong></p><p>只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 ref 解包行为与 <code>reactive()</code> 相同，但解包得到的值是只读的。</p><p>要避免深层级的转换行为，请使用 <a href="./reactivity-advanced.html#shallowreadonly">shallowReadonly()</a> 作替代。</p></li><li><p><strong>示例</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> original</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({ count: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> })</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> copy</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> readonly</span><span style="color:#E1E4E8;">(original)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">  // 用来做响应性追踪</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(copy.count)</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 更改源属性会触发其依赖的侦听器</span></span>
<span class="line"><span style="color:#E1E4E8;">original.count</span><span style="color:#F97583;">++</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 更改该只读副本将会失败，并会得到一个警告</span></span>
<span class="line"><span style="color:#E1E4E8;">copy.count</span><span style="color:#F97583;">++</span><span style="color:#6A737D;"> // warning!</span></span></code></pre></div></li></ul><h2 id="watcheffect" tabindex="-1">watchEffect() <a class="header-anchor" href="#watcheffect" aria-label="Permalink to &quot;watchEffect() {#watcheffect}&quot;">​</a></h2><p>立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> watchEffect</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#B392F0;">  effect</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">onCleanup</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> OnCleanup</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#FFAB70;">  options</span><span style="color:#F97583;">?:</span><span style="color:#B392F0;"> WatchEffectOptions</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> WatchHandle</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> OnCleanup</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">cleanupFn</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">interface</span><span style="color:#B392F0;"> WatchEffectOptions</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#FFAB70;">  flush</span><span style="color:#F97583;">?:</span><span style="color:#9ECBFF;"> &#39;pre&#39;</span><span style="color:#F97583;"> |</span><span style="color:#9ECBFF;"> &#39;post&#39;</span><span style="color:#F97583;"> |</span><span style="color:#9ECBFF;"> &#39;sync&#39;</span><span style="color:#6A737D;"> // 默认：&#39;pre&#39;</span></span>
<span class="line"><span style="color:#B392F0;">  onTrack</span><span style="color:#F97583;">?:</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">event</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> DebuggerEvent</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#B392F0;">  onTrigger</span><span style="color:#F97583;">?:</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">event</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> DebuggerEvent</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">interface</span><span style="color:#B392F0;"> WatchHandle</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  ()</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> void</span><span style="color:#6A737D;"> // 可调用，与 \`stop\` 相同</span></span>
<span class="line"><span style="color:#B392F0;">  pause</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#B392F0;">  resume</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#B392F0;">  stop</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>详细信息</strong></p><p>第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求 (参见下面的示例)。</p><p>第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。</p><p>默认情况下，侦听器将在组件渲染之前执行。设置 <code>flush: &#39;post&#39;</code> 将会使侦听器延迟到组件渲染之后再执行。详见<a href="/guide/essentials/watchers.html#callback-flush-timing">回调的触发时机</a>。在某些特殊情况下 (例如要使缓存失效)，可能有必要在响应式依赖发生改变时立即触发侦听器。这可以通过设置 <code>flush: &#39;sync&#39;</code> 来实现。然而，该设置应谨慎使用，因为如果有多个属性同时更新，这将导致一些性能和数据一致性的问题。</p><p>返回值是一个用来停止该副作用的函数。</p></li><li><p><strong>示例</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> count</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(count.value))</span></span>
<span class="line"><span style="color:#6A737D;">// -&gt; 输出 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">count.value</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#6A737D;">// -&gt; 输出 1</span></span></code></pre></div><p>停止侦听器：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> stop</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 当不再需要此侦听器时:</span></span>
<span class="line"><span style="color:#B392F0;">stop</span><span style="color:#E1E4E8;">()</span></span></code></pre></div><p>暂停/恢复侦听器：<sup class="vt-badge" data-text="3.5+"></sup></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">stop</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">pause</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">resume</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 暂停侦听器</span></span>
<span class="line"><span style="color:#B392F0;">pause</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 稍后恢复</span></span>
<span class="line"><span style="color:#B392F0;">resume</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 停止</span></span>
<span class="line"><span style="color:#B392F0;">stop</span><span style="color:#E1E4E8;">()</span></span></code></pre></div><p>副作用清理：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">onCleanup</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">response</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">cancel</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> doAsyncWork</span><span style="color:#E1E4E8;">(newId)</span></span>
<span class="line"><span style="color:#6A737D;">  // 如果 \`id\` 变化，则调用 \`cancel\`，</span></span>
<span class="line"><span style="color:#6A737D;">  // 如果之前的请求未完成，则取消该请求</span></span>
<span class="line"><span style="color:#B392F0;">  onCleanup</span><span style="color:#E1E4E8;">(cancel)</span></span>
<span class="line"><span style="color:#E1E4E8;">  data.value </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>3.5+ 中的副作用清理：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { onWatcherCleanup } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">response</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">cancel</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> doAsyncWork</span><span style="color:#E1E4E8;">(newId)</span></span>
<span class="line"><span style="color:#6A737D;">  // 如果 \`id\` 变化，则调用 \`cancel\`，</span></span>
<span class="line"><span style="color:#6A737D;">  // 如果之前的请求未完成，则取消该请求</span></span>
<span class="line"><span style="color:#B392F0;">  onWatcherCleanup</span><span style="color:#E1E4E8;">(cancel)</span></span>
<span class="line"><span style="color:#E1E4E8;">  data.value </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>选项：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {}, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  flush: </span><span style="color:#9ECBFF;">&#39;post&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#B392F0;">  onTrack</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    debugger</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#B392F0;">  onTrigger</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    debugger</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div></li><li><p><strong>参考</strong></p><ul><li><a href="/guide/essentials/watchers.html#watcheffect">指南 - 侦听器</a></li><li><a href="/guide/extras/reactivity-in-depth.html#watcher-debugging">指南 - 侦听器调试</a></li></ul></li></ul><h2 id="watchposteffect" tabindex="-1">watchPostEffect() <a class="header-anchor" href="#watchposteffect" aria-label="Permalink to &quot;watchPostEffect() {#watchposteffect}&quot;">​</a></h2><p><a href="#watcheffect"><code>watchEffect()</code></a> 使用 <code>flush: &#39;post&#39;</code> 选项时的别名。</p><h2 id="watchsynceffect" tabindex="-1">watchSyncEffect() <a class="header-anchor" href="#watchsynceffect" aria-label="Permalink to &quot;watchSyncEffect() {#watchsynceffect}&quot;">​</a></h2><p><a href="#watcheffect"><code>watchEffect()</code></a> 使用 <code>flush: &#39;sync&#39;</code> 选项时的别名。</p><h2 id="watch" tabindex="-1">watch() <a class="header-anchor" href="#watch" aria-label="Permalink to &quot;watch() {#watch}&quot;">​</a></h2><p>侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 侦听单个来源</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> watch</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="color:#FFAB70;">  source</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> WatchSource</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;,</span></span>
<span class="line"><span style="color:#FFAB70;">  callback</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> WatchCallback</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;,</span></span>
<span class="line"><span style="color:#FFAB70;">  options</span><span style="color:#F97583;">?:</span><span style="color:#B392F0;"> WatchOptions</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> WatchHandle</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 侦听多个来源</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> watch</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="color:#FFAB70;">  sources</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> WatchSource</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;[],</span></span>
<span class="line"><span style="color:#FFAB70;">  callback</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> WatchCallback</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">[]&gt;,</span></span>
<span class="line"><span style="color:#FFAB70;">  options</span><span style="color:#F97583;">?:</span><span style="color:#B392F0;"> WatchOptions</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> WatchHandle</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> WatchCallback</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#FFAB70;">  value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#FFAB70;">  oldValue</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#B392F0;">  onCleanup</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">cleanupFn</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> WatchSource</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#F97583;">  |</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#6A737D;">// ref</span></span>
<span class="line"><span style="color:#F97583;">  |</span><span style="color:#E1E4E8;"> (() </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// getter</span></span>
<span class="line"><span style="color:#F97583;">  |</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">T</span><span style="color:#F97583;"> extends</span><span style="color:#79B8FF;"> object</span><span style="color:#F97583;"> ?</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> :</span><span style="color:#79B8FF;"> never</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// 响应式对象</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">interface</span><span style="color:#B392F0;"> WatchOptions</span><span style="color:#F97583;"> extends</span><span style="color:#B392F0;"> WatchEffectOptions</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#FFAB70;">  immediate</span><span style="color:#F97583;">?:</span><span style="color:#79B8FF;"> boolean</span><span style="color:#6A737D;"> // 默认：false</span></span>
<span class="line"><span style="color:#FFAB70;">  deep</span><span style="color:#F97583;">?:</span><span style="color:#79B8FF;"> boolean</span><span style="color:#F97583;"> |</span><span style="color:#79B8FF;"> number</span><span style="color:#6A737D;"> // 默认：false</span></span>
<span class="line"><span style="color:#FFAB70;">  flush</span><span style="color:#F97583;">?:</span><span style="color:#9ECBFF;"> &#39;pre&#39;</span><span style="color:#F97583;"> |</span><span style="color:#9ECBFF;"> &#39;post&#39;</span><span style="color:#F97583;"> |</span><span style="color:#9ECBFF;"> &#39;sync&#39;</span><span style="color:#6A737D;"> // 默认：&#39;pre&#39;</span></span>
<span class="line"><span style="color:#B392F0;">  onTrack</span><span style="color:#F97583;">?:</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">event</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> DebuggerEvent</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#B392F0;">  onTrigger</span><span style="color:#F97583;">?:</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">event</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> DebuggerEvent</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#FFAB70;">  once</span><span style="color:#F97583;">?:</span><span style="color:#79B8FF;"> boolean</span><span style="color:#6A737D;"> // 默认：false (3.4+)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">interface</span><span style="color:#B392F0;"> WatchHandle</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  ()</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> void</span><span style="color:#6A737D;"> // 可调用，与 \`stop\` 相同</span></span>
<span class="line"><span style="color:#B392F0;">  pause</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#B392F0;">  resume</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#B392F0;">  stop</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>为了便于阅读，对类型进行了简化。</p></blockquote></li><li><p><strong>详细信息</strong></p><p><code>watch()</code> 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。</p><p>第一个参数是侦听器的<strong>源</strong>。这个来源可以是以下几种：</p><ul><li>一个函数，返回一个值</li><li>一个 ref</li><li>一个响应式对象</li><li>...或是由以上类型的值组成的数组</li></ul><p>第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。</p><p>当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。</p><p>第三个可选的参数是一个对象，支持以下这些选项：</p><ul><li><strong><code>immediate</code></strong>：在侦听器创建时立即触发回调。第一次调用时旧值是 <code>undefined</code>。</li><li><strong><code>deep</code></strong>：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。在 3.5+ 中，此参数还可以是指示最大遍历深度的数字。参考<a href="/guide/essentials/watchers.html#deep-watchers">深层侦听器</a>。</li><li><strong><code>flush</code></strong>：调整回调函数的刷新时机。参考<a href="/guide/essentials/watchers.html#callback-flush-timing">回调的刷新时机</a>及 <a href="/api/reactivity-core.html#watcheffect"><code>watchEffect()</code></a>。</li><li><strong><code>onTrack / onTrigger</code></strong>：调试侦听器的依赖。参考<a href="/guide/extras/reactivity-in-depth.html#watcher-debugging">调试侦听器</a>。</li><li><strong><code>once</code></strong>：(3.4+) 回调函数只会运行一次。侦听器将在回调函数首次运行后自动停止。</li></ul><p>与 <a href="#watcheffect"><code>watchEffect()</code></a> 相比，<code>watch()</code> 使我们可以：</p><ul><li>懒执行副作用；</li><li>更加明确是应该由哪个状态触发侦听器重新执行；</li><li>可以访问所侦听状态的前一个值和当前值。</li></ul></li><li><p><strong>示例</strong></p><p>侦听一个 getter 函数：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> state</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({ count: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> })</span></span>
<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> state.count,</span></span>
<span class="line"><span style="color:#E1E4E8;">  (</span><span style="color:#FFAB70;">count</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">prevCount</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">    /* ... */</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span></span></code></pre></div><p>侦听一个 ref：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> count</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(count, (</span><span style="color:#FFAB70;">count</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">prevCount</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">  /* ... */</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">([fooRef, barRef], ([</span><span style="color:#FFAB70;">foo</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">bar</span><span style="color:#E1E4E8;">], [</span><span style="color:#FFAB70;">prevFoo</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">prevBar</span><span style="color:#E1E4E8;">]) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">  /* ... */</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>当使用 getter 函数作为源时，回调只在此函数的返回值变化时才会触发。如果你想让回调在深层级变更时也能触发，你需要使用 <code>{ deep: true }</code> 强制侦听器进入深层级模式。在深层级模式时，如果回调函数由于深层级的变更而被触发，那么新值和旧值将是同一个对象。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> state</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({ count: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> })</span></span>
<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> state,</span></span>
<span class="line"><span style="color:#E1E4E8;">  (</span><span style="color:#FFAB70;">newValue</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">oldValue</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">    // newValue === oldValue</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  { deep: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span></span></code></pre></div><p>当直接侦听一个响应式对象时，侦听器会自动启用深层模式：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> state</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({ count: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> })</span></span>
<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(state, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">  /* 深层级变更状态所触发的回调 */</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p><code>watch()</code> 和 <a href="#watcheffect"><code>watchEffect()</code></a> 享有相同的刷新时机和调试选项：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(source, callback, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  flush: </span><span style="color:#9ECBFF;">&#39;post&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#B392F0;">  onTrack</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    debugger</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#B392F0;">  onTrigger</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    debugger</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>停止侦听器：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> stop</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> watch</span><span style="color:#E1E4E8;">(source, callback)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 当已不再需要该侦听器时：</span></span>
<span class="line"><span style="color:#B392F0;">stop</span><span style="color:#E1E4E8;">()</span></span></code></pre></div><p>暂停/恢复侦听器：<sup class="vt-badge" data-text="3.5+"></sup></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">stop</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">pause</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">resume</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> watch</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 暂停侦听器</span></span>
<span class="line"><span style="color:#B392F0;">pause</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 稍后恢复</span></span>
<span class="line"><span style="color:#B392F0;">resume</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 停止</span></span>
<span class="line"><span style="color:#B392F0;">stop</span><span style="color:#E1E4E8;">()</span></span></code></pre></div><p>副作用清理：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(id, </span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">newId</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">oldId</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">onCleanup</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">response</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">cancel</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> doAsyncWork</span><span style="color:#E1E4E8;">(newId)</span></span>
<span class="line"><span style="color:#6A737D;">  // 当 \`id\` 变化时，\`cancel\` 将被调用，</span></span>
<span class="line"><span style="color:#6A737D;">  // 取消之前的未完成的请求</span></span>
<span class="line"><span style="color:#B392F0;">  onCleanup</span><span style="color:#E1E4E8;">(cancel)</span></span>
<span class="line"><span style="color:#E1E4E8;">  data.value </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>3.5+ 中的副作用清理：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { onWatcherCleanup } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(id, </span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">newId</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">response</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">cancel</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> doAsyncWork</span><span style="color:#E1E4E8;">(newId)</span></span>
<span class="line"><span style="color:#B392F0;">  onWatcherCleanup</span><span style="color:#E1E4E8;">(cancel)</span></span>
<span class="line"><span style="color:#E1E4E8;">  data.value </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div></li><li><p><strong>参考</strong></p><ul><li><a href="/guide/essentials/watchers.html">指南 - 侦听器</a></li><li><a href="/guide/extras/reactivity-in-depth.html#watcher-debugging">指南 - 侦听器调试</a></li></ul></li></ul><h2 id="onwatchercleanup" tabindex="-1">onWatcherCleanup() <sup class="vt-badge" data-text="3.5+"></sup> <a class="header-anchor" href="#onwatchercleanup" aria-label="Permalink to &quot;onWatcherCleanup() &lt;sup class=&quot;vt-badge&quot; data-text=&quot;3.5+&quot; /&gt; {#onwatchercleanup}&quot;">​</a></h2><p>注册一个清理函数，在当前侦听器即将重新运行时执行。只能在 <code>watchEffect</code> 作用函数或 <code>watch</code> 回调函数的同步执行期间调用 (即不能在异步函数的 <code>await</code> 语句之后调用)。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> onWatcherCleanup</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#B392F0;">  cleanupFn</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#FFAB70;">  failSilently</span><span style="color:#F97583;">?:</span><span style="color:#79B8FF;"> boolean</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> void</span></span></code></pre></div></li><li><p><strong>示例</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { watch, onWatcherCleanup } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(id, (</span><span style="color:#FFAB70;">newId</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">response</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">cancel</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> doAsyncWork</span><span style="color:#E1E4E8;">(newId)</span></span>
<span class="line"><span style="color:#6A737D;">  // 如果 \`id\` 变化，则调用 \`cancel\`，</span></span>
<span class="line"><span style="color:#6A737D;">  // 如果之前的请求未完成，则取消该请求</span></span>
<span class="line"><span style="color:#B392F0;">  onWatcherCleanup</span><span style="color:#E1E4E8;">(cancel)</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div></li></ul>`,27)]))}const d=a(o,[["render",e]]);export{F as __pageData,d as default};
