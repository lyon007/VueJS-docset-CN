import{_ as a,c as n,b as p,o as l}from"./chunks/framework.B2oIMGqn.js";const d=JSON.parse('{"title":"Props","description":"","frontmatter":{},"headers":[{"level":2,"title":"Props 声明","slug":"props-declaration","link":"#props-declaration","children":[]},{"level":2,"title":"响应式 Props 解构","slug":"reactive-props-destructure","link":"#reactive-props-destructure","children":[{"level":3,"title":"将解构的 props 传递到函数中","slug":"passing-destructured-props-into-functions","link":"#passing-destructured-props-into-functions","children":[]}],"compositionOnly":true},{"level":2,"title":"传递 prop 的细节","slug":"prop-passing-details","link":"#prop-passing-details","children":[{"level":3,"title":"Prop 名字格式","slug":"prop-name-casing","link":"#prop-name-casing","children":[]},{"level":3,"title":"静态 vs. 动态 Props","slug":"static-vs-dynamic-props","link":"#static-vs-dynamic-props","children":[]},{"level":3,"title":"传递不同的值类型","slug":"passing-different-value-types","link":"#passing-different-value-types","children":[]},{"level":3,"title":"使用一个对象绑定多个 prop","slug":"binding-multiple-properties-using-an-object","link":"#binding-multiple-properties-using-an-object","children":[]}]},{"level":2,"title":"单向数据流","slug":"one-way-data-flow","link":"#one-way-data-flow","children":[{"level":3,"title":"更改对象 / 数组类型的 props","slug":"mutating-object-array-props","link":"#mutating-object-array-props","children":[]}]},{"level":2,"title":"Prop 校验","slug":"prop-validation","link":"#prop-validation","children":[{"level":3,"title":"运行时类型检查","slug":"runtime-type-checks","link":"#runtime-type-checks","children":[]},{"level":3,"title":"可为 null 的类型","slug":"nullable-type","link":"#nullable-type","children":[]}]},{"level":2,"title":"Boolean 类型转换","slug":"boolean-casting","link":"#boolean-casting","children":[]}],"relativePath":"guide/components/props.md","filePath":"guide/components/props.md"}'),o={name:"guide/components/props.md"};function e(t,s,c,r,i,E){return l(),n("div",null,s[0]||(s[0]=[p(`<h1 id="props" tabindex="-1">Props <a class="header-anchor" href="#props" aria-label="Permalink to &quot;Props {#props}&quot;">​</a></h1><blockquote><p>此章节假设你已经看过了<a href="/guide/essentials/component-basics.html">组件基础</a>。若你还不了解组件是什么，请先阅读该章节。</p></blockquote><h2 id="props-declaration" tabindex="-1">Props 声明 <a class="header-anchor" href="#props-declaration" aria-label="Permalink to &quot;Props 声明 {#props-declaration}&quot;">​</a></h2><p>一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute (关于透传 attribute，我们会在<a href="/guide/components/attrs.html">专门的章节</a>中讨论)。</p><div class="composition-api"><p>在使用 <code>&lt;script setup&gt;</code> 的单文件组件中，props 可以使用 <code>defineProps()</code> 宏来声明：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#B392F0;"> setup</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> props</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> defineProps</span><span style="color:#E1E4E8;">([</span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(props.foo)</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>在没有使用 <code>&lt;script setup&gt;</code> 的组件中，props 可以使用 <a href="/api/options-state.html#props"><code>props</code></a> 选项来声明：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: [</span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#B392F0;">  setup</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">props</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">    // setup() 接收 props 作为第一个参数</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(props.foo)</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>注意传递给 <code>defineProps()</code> 的参数和提供给 <code>props</code> 选项的值是相同的，两种声明方式背后其实使用的都是 props 选项。</p></div><div class="options-api"><p>props 需要使用 <a href="/api/options-state.html#props"><code>props</code></a> 选项来定义：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: [</span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#B392F0;">  created</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // props 会暴露到 \`this\` 上</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.foo)</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><p>除了使用字符串数组来声明 props 外，还可以使用对象的形式：</p><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    title: String,</span></span>
<span class="line"><span style="color:#E1E4E8;">    likes: Number</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 使用 &lt;script setup&gt;</span></span>
<span class="line"><span style="color:#B392F0;">defineProps</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  title: String,</span></span>
<span class="line"><span style="color:#E1E4E8;">  likes: Number</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 非 &lt;script setup&gt;</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    title: String,</span></span>
<span class="line"><span style="color:#E1E4E8;">    likes: Number</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><p>对于以对象形式声明的每个属性，key 是 prop 的名称，而值则是该 prop 预期类型的构造函数。比如，如果要求一个 prop 的值是 <code>number</code> 类型，则可使用 <code>Number</code> 构造函数作为其声明的值。</p><p>对象形式的 props 声明不仅可以一定程度上作为组件的文档，而且如果其他开发者在使用你的组件时传递了错误的类型，也会在浏览器控制台中抛出警告。我们将在本章节稍后进一步讨论有关 <a href="#prop-validation">prop 校验</a>的更多细节。</p><div class="options-api"><p>TypeScript 用户请参考：<a href="/guide/typescript/options-api.html#typing-component-props">为组件 Props 标注类型</a> <sup class="vt-badge ts"></sup></p></div><div class="composition-api"><p>如果你正在搭配 TypeScript 使用 <code>&lt;script setup&gt;</code>，也可以使用类型标注来声明 props：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#B392F0;"> setup</span><span style="color:#B392F0;"> lang</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;ts&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#B392F0;">defineProps</span><span style="color:#E1E4E8;">&lt;{</span></span>
<span class="line"><span style="color:#FFAB70;">  title</span><span style="color:#F97583;">?:</span><span style="color:#79B8FF;"> string</span></span>
<span class="line"><span style="color:#FFAB70;">  likes</span><span style="color:#F97583;">?:</span><span style="color:#79B8FF;"> number</span></span>
<span class="line"><span style="color:#E1E4E8;">}&gt;()</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>更多关于基于类型的声明的细节请参考<a href="/guide/typescript/composition-api.html#typing-component-props">组件 props 类型标注</a>。<sup class="vt-badge ts"></sup></p></div><div class="composition-api"><h2 id="reactive-props-destructure" tabindex="-1">响应式 Props 解构 <sup class="vt-badge" data-text="3.5+"></sup> <a class="header-anchor" href="#reactive-props-destructure" aria-label="Permalink to &quot;响应式 Props 解构 &lt;sup class=&quot;vt-badge&quot; data-text=&quot;3.5+&quot; /&gt; \\*\\* {#reactive-props-destructure}&quot;">​</a></h2><p>Vue 的响应系统基于属性访问跟踪状态的使用情况。例如，在计算属性或侦听器中访问 <code>props.foo</code> 时，<code>foo</code> 属性将被跟踪为依赖项。</p><p>因此，在以下代码的情况下：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">foo</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> defineProps</span><span style="color:#E1E4E8;">([</span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">  // 在 3.5 之前只运行一次</span></span>
<span class="line"><span style="color:#6A737D;">  // 在 3.5+ 中在 &quot;foo&quot; prop 变化时重新执行</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(foo)</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>在 3.4 及以下版本，<code>foo</code> 是一个实际的常量，永远不会改变。在 3.5 及以上版本，当在同一个 <code>&lt;script setup&gt;</code> 代码块中访问由 <code>defineProps</code> 解构的变量时，Vue 编译器会自动在前面添加 <code>props.</code>。因此，上面的代码等同于以下代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> props</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> defineProps</span><span style="color:#E1E4E8;">([</span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">  // \`foo\` 由编译器转换为 \`props.foo\`</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(props.foo)</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>此外，你可以使用 JavaScript 原生的默认值语法声明 props 默认值。这在使用基于类型的 props 声明时特别有用。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">foo</span><span style="color:#F97583;"> =</span><span style="color:#9ECBFF;"> &#39;hello&#39;</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> defineProps</span><span style="color:#E1E4E8;">&lt;{ </span><span style="color:#FFAB70;">foo</span><span style="color:#F97583;">?:</span><span style="color:#79B8FF;"> string</span><span style="color:#E1E4E8;"> }&gt;()</span></span></code></pre></div><p>如果你希望在 IDE 中在解构的 props 和普通变量之间有更多视觉上的区分，Vue 的 VSCode 扩展提供了一个设置来启用解构 props 的内联提示。</p><h3 id="passing-destructured-props-into-functions" tabindex="-1">将解构的 props 传递到函数中 <a class="header-anchor" href="#passing-destructured-props-into-functions" aria-label="Permalink to &quot;将解构的 props 传递到函数中 {#passing-destructured-props-into-functions}&quot;">​</a></h3><p>当我们将解构的 prop 传递到函数中时，例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">foo</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> defineProps</span><span style="color:#E1E4E8;">([</span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(foo, </span><span style="color:#6A737D;">/* ... */</span><span style="color:#E1E4E8;">)</span></span></code></pre></div><p>这并不会按预期工作，因为它等价于 <code>watch(props.foo, ...)</code>——我们给 <code>watch</code> 传递的是一个值而不是响应式数据源。实际上，Vue 的编译器会捕捉这种情况并发出警告。</p><p>与使用 <code>watch(() =&gt; props.foo, ...)</code> 来侦听普通 prop 类似，我们也可以通过将其包装在 getter 中来侦听解构的 prop：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> foo, </span><span style="color:#6A737D;">/* ... */</span><span style="color:#E1E4E8;">)</span></span></code></pre></div><p>此外，当我们需要传递解构的 prop 到外部函数中并保持响应性时，这是推荐做法：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">useComposable</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> foo)</span></span></code></pre></div><p>外部函数可以调用 getter (或使用 <a href="/api/reactivity-utilities.html#tovalue">toValue</a> 进行规范化) 来追踪提供的 prop 变更。例如，在计算属性或侦听器的 getter 中。</p></div><h2 id="prop-passing-details" tabindex="-1">传递 prop 的细节 <a class="header-anchor" href="#prop-passing-details" aria-label="Permalink to &quot;传递 prop 的细节 {#prop-passing-details}&quot;">​</a></h2><h3 id="prop-name-casing" tabindex="-1">Prop 名字格式 <a class="header-anchor" href="#prop-name-casing" aria-label="Permalink to &quot;Prop 名字格式 {#prop-name-casing}&quot;">​</a></h3><p>如果一个 prop 的名字很长，应使用 camelCase 形式，因为它们是合法的 JavaScript 标识符，可以直接在模板的表达式中使用，也可以避免在作为属性 key 名时必须加上引号。</p><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">defineProps</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  greetingMessage: String</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div></div><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    greetingMessage: String</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">span</span><span style="color:#E1E4E8;">&gt;{{ greetingMessage }}&lt;/</span><span style="color:#85E89D;">span</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>虽然理论上你也可以在向子组件传递 props 时使用 camelCase 形式 (使用 <a href="/guide/essentials/component-basics.html#in-dom-template-parsing-caveats">DOM 内模板</a>时例外)，但实际上为了和 HTML attribute 对齐，我们通常会将其写为 kebab-case 形式：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">MyComponent</span><span style="color:#B392F0;"> greeting-message</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;hello&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>对于组件名我们推荐使用 <a href="/guide/components/registration.html#component-name-casing">PascalCase</a>，因为这提高了模板的可读性，能帮助我们区分 Vue 组件和原生 HTML 元素。然而对于传递 props 来说，使用 camelCase 并没有太多优势，因此我们推荐更贴近 HTML 的书写风格。</p><h3 id="static-vs-dynamic-props" tabindex="-1">静态 vs. 动态 Props <a class="header-anchor" href="#static-vs-dynamic-props" aria-label="Permalink to &quot;静态 vs. 动态 Props {#static-vs-dynamic-props}&quot;">​</a></h3><p>至此，你已经见过了很多像这样的静态值形式的 props：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#B392F0;"> title</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;My journey with Vue&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>相应地，还有使用 <code>v-bind</code> 或缩写 <code>:</code> 来进行动态绑定的 props：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 根据一个变量的值动态传入 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">title</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">post.title</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 根据一个更复杂表达式的值动态传入 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">title</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">post.title </span><span style="color:#F97583;">+</span><span style="color:#9ECBFF;"> &#39; by &#39;</span><span style="color:#F97583;"> +</span><span style="color:#E1E4E8;"> post.author.name</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre></div><h3 id="passing-different-value-types" tabindex="-1">传递不同的值类型 <a class="header-anchor" href="#passing-different-value-types" aria-label="Permalink to &quot;传递不同的值类型 {#passing-different-value-types}&quot;">​</a></h3><p>在上述的两个例子中，我们只传入了字符串值，但实际上<strong>任何</strong>类型的值都可以作为 props 的值被传递。</p><h4 id="number" tabindex="-1">Number <a class="header-anchor" href="#number" aria-label="Permalink to &quot;Number {#number}&quot;">​</a></h4><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 虽然 \`42\` 是个常量，我们还是需要使用 v-bind --&gt;</span></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">likes</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#79B8FF;">42</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 根据一个变量的值动态传入 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">likes</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">post.likes</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre></div><h4 id="boolean" tabindex="-1">Boolean <a class="header-anchor" href="#boolean" aria-label="Permalink to &quot;Boolean {#boolean}&quot;">​</a></h4><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 仅写上 prop 但不传值，会隐式转换为 \`true\` --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#B392F0;"> is-published</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 虽然 \`false\` 是静态的值，我们还是需要使用 v-bind --&gt;</span></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">is-published</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#79B8FF;">false</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 根据一个变量的值动态传入 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">is-published</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">post.isPublished</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre></div><h4 id="array" tabindex="-1">Array <a class="header-anchor" href="#array" aria-label="Permalink to &quot;Array {#array}&quot;">​</a></h4><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 虽然这个数组是个常量，我们还是需要使用 v-bind --&gt;</span></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">comment-ids</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">234</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">266</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">273</span><span style="color:#E1E4E8;">]</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 根据一个变量的值动态传入 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">comment-ids</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">post.commentIds</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre></div><h4 id="object" tabindex="-1">Object <a class="header-anchor" href="#object" aria-label="Permalink to &quot;Object {#object}&quot;">​</a></h4><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 虽然这个对象字面量是个常量，我们还是需要使用 v-bind --&gt;</span></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span></span>
<span class="line"><span style="color:#E1E4E8;">  :</span><span style="color:#B392F0;">author</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">    name: </span><span style="color:#9ECBFF;">&#39;Veronica&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    company: </span><span style="color:#9ECBFF;">&#39;Veridian Dynamics&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span><span style="color:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 根据一个变量的值动态传入 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">author</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">post.author</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre></div><h3 id="binding-multiple-properties-using-an-object" tabindex="-1">使用一个对象绑定多个 prop <a class="header-anchor" href="#binding-multiple-properties-using-an-object" aria-label="Permalink to &quot;使用一个对象绑定多个 prop {#binding-multiple-properties-using-an-object}&quot;">​</a></h3><p>如果你想要将一个对象的所有属性都当作 props 传入，你可以使用<a href="/guide/essentials/template-syntax.html#dynamically-binding-multiple-attributes">没有参数的 <code>v-bind</code></a>，即只使用 <code>v-bind</code> 而非 <code>:prop-name</code>。例如，这里有一个 <code>post</code> 对象：</p><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#B392F0;">  data</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      post: {</span></span>
<span class="line"><span style="color:#E1E4E8;">        id: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">        title: </span><span style="color:#9ECBFF;">&#39;My Journey with Vue&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> post</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  id: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  title: </span><span style="color:#9ECBFF;">&#39;My Journey with Vue&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><p>以及下面的模板：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#B392F0;"> v-bind</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">post</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>而这实际上等价于：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">BlogPost</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">post.id</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">title</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">post.title</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre></div><h2 id="one-way-data-flow" tabindex="-1">单向数据流 <a class="header-anchor" href="#one-way-data-flow" aria-label="Permalink to &quot;单向数据流 {#one-way-data-flow}&quot;">​</a></h2><p>所有的 props 都遵循着<strong>单向绑定</strong>原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。</p><p>另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你<strong>不应该</strong>在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告：</p><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> props</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> defineProps</span><span style="color:#E1E4E8;">([</span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// ❌ 警告！prop 是只读的！</span></span>
<span class="line"><span style="color:#E1E4E8;">props.foo </span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;"> &#39;bar&#39;</span></span></code></pre></div></div><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: [</span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#B392F0;">  created</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // ❌ 警告！prop 是只读的！</span></span>
<span class="line"><span style="color:#79B8FF;">    this</span><span style="color:#E1E4E8;">.foo </span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;"> &#39;bar&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><p>导致你想要更改一个 prop 的需求通常来源于以下两种场景：</p><ol><li><p><strong>prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性</strong>。在这种情况下，最好是新定义一个局部数据属性，从 props 上获取初始值即可：</p><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> props</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> defineProps</span><span style="color:#E1E4E8;">([</span><span style="color:#9ECBFF;">&#39;initialCounter&#39;</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 计数器只是将 props.initialCounter 作为初始值</span></span>
<span class="line"><span style="color:#6A737D;">// 像下面这样做就使 prop 和后续更新无关了</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> counter</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(props.initialCounter)</span></span></code></pre></div></div><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: [</span><span style="color:#9ECBFF;">&#39;initialCounter&#39;</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#B392F0;">  data</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">      // 计数器只是将 this.initialCounter 作为初始值</span></span>
<span class="line"><span style="color:#6A737D;">      // 像下面这样做就使 prop 和后续更新无关了</span></span>
<span class="line"><span style="color:#E1E4E8;">      counter: </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.initialCounter</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div></li><li><p><strong>需要对传入的 prop 值做进一步的转换</strong>。在这种情况中，最好是基于该 prop 值定义一个计算属性：</p><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> props</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> defineProps</span><span style="color:#E1E4E8;">([</span><span style="color:#9ECBFF;">&#39;size&#39;</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 该 prop 变更时计算属性也会自动更新</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> normalizedSize</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> computed</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> props.size.</span><span style="color:#B392F0;">trim</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">toLowerCase</span><span style="color:#E1E4E8;">())</span></span></code></pre></div></div><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: [</span><span style="color:#9ECBFF;">&#39;size&#39;</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">  computed: {</span></span>
<span class="line"><span style="color:#6A737D;">    // 该 prop 变更时计算属性也会自动更新</span></span>
<span class="line"><span style="color:#B392F0;">    normalizedSize</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">      return</span><span style="color:#79B8FF;"> this</span><span style="color:#E1E4E8;">.size.</span><span style="color:#B392F0;">trim</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">toLowerCase</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div></li></ol><h3 id="mutating-object-array-props" tabindex="-1">更改对象 / 数组类型的 props <a class="header-anchor" href="#mutating-object-array-props" aria-label="Permalink to &quot;更改对象 / 数组类型的 props {#mutating-object-array-props}&quot;">​</a></h3><p>当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然<strong>可以</strong>更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，对 Vue 来说，阻止这种更改需要付出的代价异常昂贵。</p><p>这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。在大多数场景下，子组件应该<a href="/guide/components/events.html">抛出一个事件</a>来通知父组件做出改变。</p><h2 id="prop-validation" tabindex="-1">Prop 校验 <a class="header-anchor" href="#prop-validation" aria-label="Permalink to &quot;Prop 校验 {#prop-validation}&quot;">​</a></h2><p>Vue 组件可以更细致地声明对传入的 props 的校验要求。比如我们上面已经看到过的类型声明，如果传入的值不满足类型要求，Vue 会在浏览器控制台中抛出警告来提醒使用者。这在开发给其他开发者使用的组件时非常有用。</p><p>要声明对 props 的校验，你可以向 <span class="composition-api"><code>defineProps()</code> 宏</span><span class="options-api"><code>props</code> 选项</span>提供一个带有 props 校验选项的对象，例如：</p><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">defineProps</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#6A737D;">  // 基础类型检查</span></span>
<span class="line"><span style="color:#6A737D;">  // （给出 \`null\` 和 \`undefined\` 值则会跳过任何类型检查）</span></span>
<span class="line"><span style="color:#E1E4E8;">  propA: Number,</span></span>
<span class="line"><span style="color:#6A737D;">  // 多种可能的类型</span></span>
<span class="line"><span style="color:#E1E4E8;">  propB: [String, Number],</span></span>
<span class="line"><span style="color:#6A737D;">  // 必传，且为 String 类型</span></span>
<span class="line"><span style="color:#E1E4E8;">  propC: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    type: String,</span></span>
<span class="line"><span style="color:#E1E4E8;">    required: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#6A737D;">  // 必传但可为 null 的字符串</span></span>
<span class="line"><span style="color:#E1E4E8;">  propD: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    type: [String, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">    required: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#6A737D;">  // Number 类型的默认值</span></span>
<span class="line"><span style="color:#E1E4E8;">  propE: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    type: Number,</span></span>
<span class="line"><span style="color:#E1E4E8;">    default: </span><span style="color:#79B8FF;">100</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#6A737D;">  // 对象类型的默认值</span></span>
<span class="line"><span style="color:#E1E4E8;">  propF: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    type: Object,</span></span>
<span class="line"><span style="color:#6A737D;">    // 对象或数组的默认值</span></span>
<span class="line"><span style="color:#6A737D;">    // 必须从一个工厂函数返回。</span></span>
<span class="line"><span style="color:#6A737D;">    // 该函数接收组件所接收到的原始 prop 作为参数。</span></span>
<span class="line"><span style="color:#B392F0;">    default</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">rawProps</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">      return</span><span style="color:#E1E4E8;"> { message: </span><span style="color:#9ECBFF;">&#39;hello&#39;</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#6A737D;">  // 自定义类型校验函数</span></span>
<span class="line"><span style="color:#6A737D;">  // 在 3.4+ 中完整的 props 作为第二个参数传入</span></span>
<span class="line"><span style="color:#E1E4E8;">  propG: {</span></span>
<span class="line"><span style="color:#B392F0;">    validator</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">props</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">      // The value must match one of these strings</span></span>
<span class="line"><span style="color:#F97583;">      return</span><span style="color:#E1E4E8;"> [</span><span style="color:#9ECBFF;">&#39;success&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;warning&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;danger&#39;</span><span style="color:#E1E4E8;">].</span><span style="color:#B392F0;">includes</span><span style="color:#E1E4E8;">(value)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#6A737D;">  // 函数类型的默认值</span></span>
<span class="line"><span style="color:#E1E4E8;">  propH: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    type: Function,</span></span>
<span class="line"><span style="color:#6A737D;">    // 不像对象或数组的默认，这不是一个</span></span>
<span class="line"><span style="color:#6A737D;">    // 工厂函数。这会是一个用来作为默认值的函数</span></span>
<span class="line"><span style="color:#B392F0;">    default</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">      return</span><span style="color:#9ECBFF;"> &#39;Default function&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>defineProps()</code> 宏中的参数<strong>不可以访问 <code>&lt;script setup&gt;</code> 中定义的其他变量</strong>，因为在编译时整个表达式都会被移到外部的函数中。</p></div></div><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="color:#6A737D;">    // 基础类型检查</span></span>
<span class="line"><span style="color:#6A737D;">    //（给出 \`null\` 和 \`undefined\` 值则会跳过任何类型检查）</span></span>
<span class="line"><span style="color:#E1E4E8;">    propA: Number,</span></span>
<span class="line"><span style="color:#6A737D;">    // 多种可能的类型</span></span>
<span class="line"><span style="color:#E1E4E8;">    propB: [String, Number],</span></span>
<span class="line"><span style="color:#6A737D;">    // 必传，且为 String 类型</span></span>
<span class="line"><span style="color:#E1E4E8;">    propC: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      type: String,</span></span>
<span class="line"><span style="color:#E1E4E8;">      required: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#6A737D;">    // 必传但可为 null 的字符串</span></span>
<span class="line"><span style="color:#E1E4E8;">    propD: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      type: [String, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">      required: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#6A737D;">    // Number 类型的默认值</span></span>
<span class="line"><span style="color:#E1E4E8;">    propE: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      type: Number,</span></span>
<span class="line"><span style="color:#E1E4E8;">      default: </span><span style="color:#79B8FF;">100</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#6A737D;">    // 对象类型的默认值</span></span>
<span class="line"><span style="color:#E1E4E8;">    propF: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      type: Object,</span></span>
<span class="line"><span style="color:#6A737D;">      // 对象或者数组应当用工厂函数返回。</span></span>
<span class="line"><span style="color:#6A737D;">      // 工厂函数会收到组件所接收的原始 props</span></span>
<span class="line"><span style="color:#6A737D;">      // 作为参数</span></span>
<span class="line"><span style="color:#B392F0;">      default</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">rawProps</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> { message: </span><span style="color:#9ECBFF;">&#39;hello&#39;</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#6A737D;">    // 自定义类型校验函数</span></span>
<span class="line"><span style="color:#6A737D;">    // 在 3.4+ 中完整的 props 作为第二个参数传入</span></span>
<span class="line"><span style="color:#E1E4E8;">    propG: {</span></span>
<span class="line"><span style="color:#B392F0;">      validator</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">props</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">        // The value must match one of these strings</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> [</span><span style="color:#9ECBFF;">&#39;success&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;warning&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;danger&#39;</span><span style="color:#E1E4E8;">].</span><span style="color:#B392F0;">includes</span><span style="color:#E1E4E8;">(value)</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#6A737D;">    // 函数类型的默认值</span></span>
<span class="line"><span style="color:#E1E4E8;">    propH: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      type: Function,</span></span>
<span class="line"><span style="color:#6A737D;">      // 不像对象或数组的默认，这不是一个</span></span>
<span class="line"><span style="color:#6A737D;">      // 工厂函数。这会是一个用来作为默认值的函数</span></span>
<span class="line"><span style="color:#B392F0;">      default</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#9ECBFF;"> &#39;Default function&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><p>一些补充细节：</p><ul><li><p>所有 prop 默认都是可选的，除非声明了 <code>required: true</code>。</p></li><li><p>除 <code>Boolean</code> 外的未传递的可选 prop 将会有一个默认值 <code>undefined</code>。</p></li><li><p><code>Boolean</code> 类型的未传递 prop 将被转换为 <code>false</code>。这可以通过为它设置 <code>default</code> 来更改——例如：设置为 <code>default: undefined</code> 将与非布尔类型的 prop 的行为保持一致。</p></li><li><p>如果声明了 <code>default</code> 值，那么在 prop 的值被解析为 <code>undefined</code> 时，无论 prop 是未被传递还是显式指明的 <code>undefined</code>，都会改为 <code>default</code> 值。</p></li></ul><p>当 prop 的校验失败后，Vue 会抛出一个控制台警告 (在开发模式下)。</p><div class="composition-api"><p>如果使用了<a href="/api/sfc-script-setup.html#type-only-props-emit-declarations">基于类型的 prop 声明</a> <sup class="vt-badge ts"></sup>，Vue 会尽最大努力在运行时按照 prop 的类型标注进行编译。举例来说，<code>defineProps&lt;{ msg: string }&gt;</code> 会被编译为 <code>{ msg: { type: String, required: true }}</code>。</p></div><div class="options-api"><div class="tip custom-block"><p class="custom-block-title">注意</p><p>注意 prop 的校验是在组件实例被创建<strong>之前</strong>，所以实例的属性 (比如 <code>data</code>、<code>computed</code> 等) 将在 <code>default</code> 或 <code>validator</code> 函数中不可用。</p></div></div><h3 id="runtime-type-checks" tabindex="-1">运行时类型检查 <a class="header-anchor" href="#runtime-type-checks" aria-label="Permalink to &quot;运行时类型检查 {#runtime-type-checks}&quot;">​</a></h3><p>校验选项中的 <code>type</code> 可以是下列这些原生构造函数：</p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Array</code></li><li><code>Object</code></li><li><code>Date</code></li><li><code>Function</code></li><li><code>Symbol</code></li><li><code>Error</code></li></ul><p>另外，<code>type</code> 也可以是自定义的类或构造函数，Vue 将会通过 <code>instanceof</code> 来检查类型是否匹配。例如下面这个类：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#B392F0;"> Person</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  constructor</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">firstName</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">lastName</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#79B8FF;">    this</span><span style="color:#E1E4E8;">.firstName </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> firstName</span></span>
<span class="line"><span style="color:#79B8FF;">    this</span><span style="color:#E1E4E8;">.lastName </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> lastName</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>你可以将其作为一个 prop 的类型：</p><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">defineProps</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  author: Person</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div></div><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    author: Person</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><p>Vue 会通过 <code>instanceof Person</code> 来校验 <code>author</code> prop 的值是否是 <code>Person</code> 类的一个实例。</p><h3 id="nullable-type" tabindex="-1">可为 null 的类型 <a class="header-anchor" href="#nullable-type" aria-label="Permalink to &quot;可为 null 的类型 {#nullable-type}&quot;">​</a></h3><p>如果该类型是必传但可为 null 的，你可以用一个包含 <code>null</code> 的数组语法：</p><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">defineProps</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  id: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    type: [String, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">    required: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div></div><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    id: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      type: [String, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">      required: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><p>注意如果 <code>type</code> 仅为 <code>null</code> 而非使用数组语法，它将允许任何类型。</p><h2 id="boolean-casting" tabindex="-1">Boolean 类型转换 <a class="header-anchor" href="#boolean-casting" aria-label="Permalink to &quot;Boolean 类型转换 {#boolean-casting}&quot;">​</a></h2><p>为了更贴近原生 boolean attributes 的行为，声明为 <code>Boolean</code> 类型的 props 有特别的类型转换规则。以带有如下声明的 <code>&lt;MyComponent&gt;</code> 组件为例：</p><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">defineProps</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  disabled: Boolean</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div></div><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    disabled: Boolean</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><p>该组件可以被这样使用：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 等同于传入 :disabled=&quot;true&quot; --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">MyComponent</span><span style="color:#B392F0;"> disabled</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 等同于传入 :disabled=&quot;false&quot; --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">MyComponent</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>当一个 prop 被声明为允许多种类型时，<code>Boolean</code> 的转换规则也将被应用。然而，当同时允许 <code>String</code> 和 <code>Boolean</code> 时，有一种边缘情况——只有当 <code>Boolean</code> 出现在 <code>String</code> 之前时，<code>Boolean</code> 转换规则才适用：</p><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// disabled 将被转换为 true</span></span>
<span class="line"><span style="color:#B392F0;">defineProps</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  disabled: [Boolean, Number]</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// disabled 将被转换为 true</span></span>
<span class="line"><span style="color:#B392F0;">defineProps</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  disabled: [Boolean, String]</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// disabled 将被转换为 true</span></span>
<span class="line"><span style="color:#B392F0;">defineProps</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  disabled: [Number, Boolean]</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// disabled 将被解析为空字符串 (disabled=&quot;&quot;)</span></span>
<span class="line"><span style="color:#B392F0;">defineProps</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  disabled: [String, Boolean]</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div></div><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// disabled 将被转换为 true</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    disabled: [Boolean, Number]</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// disabled 将被转换为 true</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    disabled: [Boolean, String]</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// disabled 将被转换为 true</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    disabled: [Number, Boolean]</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// disabled 将被解析为空字符串 (disabled=&quot;&quot;)</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    disabled: [String, Boolean]</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div>`,89)]))}const u=a(o,[["render",e]]);export{d as __pageData,u as default};
