import{_ as a,c as l,b as e,o as n}from"./chunks/framework.B2oIMGqn.js";const d=JSON.parse('{"title":"内置的特殊 Attributes","description":"","frontmatter":{},"headers":[{"level":2,"title":"key","slug":"key","link":"#key","children":[]},{"level":2,"title":"ref","slug":"ref","link":"#ref","children":[]},{"level":2,"title":"is","slug":"is","link":"#is","children":[]}],"relativePath":"api/built-in-special-attributes.md","filePath":"api/built-in-special-attributes.md"}'),t={name:"api/built-in-special-attributes.md"};function p(o,s,c,r,i,E){return n(),l("div",null,s[0]||(s[0]=[e(`<h1 id="built-in-special-attributes" tabindex="-1">内置的特殊 Attributes <a class="header-anchor" href="#built-in-special-attributes" aria-label="Permalink to &quot;内置的特殊 Attributes {#built-in-special-attributes}&quot;">​</a></h1><h2 id="key" tabindex="-1">key <a class="header-anchor" href="#key" aria-label="Permalink to &quot;key {#key}&quot;">​</a></h2><p><code>key</code> 这个特殊的 attribute 主要作为 Vue 的虚拟 DOM 算法提示，在比较新旧节点列表时用于识别 vnode。</p><ul><li><p><strong>预期</strong>：<code>number | string | symbol</code></p></li><li><p><strong>详细信息</strong></p><p>在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新/复用相同类型的元素。如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除/销毁 key 已经不存在的元素。</p><p>同一个父元素下的子元素必须具有<strong>唯一的 key</strong>。重复的 key 将会导致渲染异常。</p><p>最常见的用例是与 <code>v-for</code> 结合：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">ul</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">li</span><span style="color:#B392F0;"> v-for</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">item </span><span style="color:#F97583;">in</span><span style="color:#E1E4E8;"> items</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">key</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">item.id</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">&gt;...&lt;/</span><span style="color:#85E89D;">li</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">ul</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>也可以用于强制替换一个元素/组件而不是复用它。当你想这么做时它可能会很有用：</p><ul><li>在适当的时候触发组件的生命周期钩子</li><li>触发过渡</li></ul><p>举例来说：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">transition</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">span</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">key</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">text</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">&gt;{{ text }}&lt;/</span><span style="color:#85E89D;">span</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">transition</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>当 <code>text</code> 变化时，<code>&lt;span&gt;</code> 总是会被替换而不是更新，因此 transition 将会被触发。</p></li><li><p><strong>参考</strong><a href="/guide/essentials/list.html#maintaining-state-with-key">指南 - 列表渲染 - 通过 <code>key</code> 管理状态</a></p></li></ul><h2 id="ref" tabindex="-1">ref <a class="header-anchor" href="#ref" aria-label="Permalink to &quot;ref {#ref}&quot;">​</a></h2><p>用于注册<a href="/guide/essentials/template-refs.html">模板引用</a>。</p><ul><li><p><strong>预期</strong>：<code>string | Function</code></p></li><li><p><strong>详细信息</strong></p><p><code>ref</code> 用于注册元素或子组件的引用。</p><p>使用选项式 API，引用将被注册在组件的 <code>this.$refs</code> 对象里：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 存储为 this.$refs.p --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">p</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;p&quot;</span><span style="color:#E1E4E8;">&gt;hello&lt;/</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>使用组合式 API，引用将存储在与名字匹配的 ref 里：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#B392F0;"> setup</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { useTemplateRef } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> pRef</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> useTemplateRef</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;p&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">p</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;p&quot;</span><span style="color:#E1E4E8;">&gt;hello&lt;/</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>如果用于普通 DOM 元素，引用将是元素本身；如果用于子组件，引用将是子组件的实例。</p><p>或者 <code>ref</code> 可以接收一个函数值，用于对存储引用位置的完全控制：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">ChildComponent</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">el</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> child </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> el</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>关于 ref 注册时机的重要说明：因为 ref 本身是作为渲染函数的结果来创建的，必须等待组件挂载后才能对它进行访问。</p><p><code>this.$refs</code> 也是非响应式的，因此你不应该尝试在模板中使用它来进行数据绑定。</p></li><li><p><strong>参考</strong></p><ul><li><a href="/guide/essentials/template-refs.html">指南 - 模板引用</a></li><li><a href="/guide/typescript/composition-api.html#typing-template-refs">指南 - 为模板引用标注类型</a> <sup class="vt-badge ts"></sup></li><li><a href="/guide/typescript/composition-api.html#typing-component-template-refs">指南 - 为组件模板引用标注类型</a> <sup class="vt-badge ts"></sup></li></ul></li></ul><h2 id="is" tabindex="-1">is <a class="header-anchor" href="#is" aria-label="Permalink to &quot;is {#is}&quot;">​</a></h2><p>用于绑定<a href="/guide/essentials/component-basics.html#dynamic-components">动态组件</a>。</p><ul><li><p><strong>预期</strong>：<code>string | Component</code></p></li><li><p><strong>用于原生元素</strong></p><ul><li>仅在 3.1+ 中支持</li></ul><p>当 <code>is</code> attribute 用于原生 HTML 元素时，它将被当作 <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example" target="_blank" rel="noreferrer">Customized built-in element</a>，其为原生 web 平台的特性。</p><p>但是，在这种用例中，你可能需要 Vue 用其组件来替换原生元素，如 <a href="/guide/essentials/component-basics.html#in-dom-template-parsing-caveats">DOM 内模板解析注意事项</a>所述。你可以在 <code>is</code> attribute 的值中加上 <code>vue:</code> 前缀，这样 Vue 就会把该元素渲染为 Vue 组件：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">table</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">tr</span><span style="color:#B392F0;"> is</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;vue:my-row-component&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">tr</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">table</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>参考</strong></p><ul><li><a href="/api/built-in-special-elements.html#component">内置特殊元素 - <code>&lt;component&gt;</code></a></li><li><a href="/guide/essentials/component-basics.html#dynamic-components">动态组件</a></li></ul></li></ul>`,10)]))}const u=a(t,[["render",p]]);export{d as __pageData,u as default};
