import{_ as n,c as a,b as e,o as l}from"./chunks/framework.B2oIMGqn.js";const y=JSON.parse('{"title":"Suspense","description":"","frontmatter":{"outline":"deep"},"headers":[{"level":2,"title":"异步依赖","slug":"async-dependencies","link":"#async-dependencies","children":[{"level":3,"title":"async setup()","slug":"async-setup","link":"#async-setup","children":[]},{"level":3,"title":"异步组件","slug":"async-components","link":"#async-components","children":[]}]},{"level":2,"title":"加载中状态","slug":"loading-state","link":"#loading-state","children":[]},{"level":2,"title":"事件","slug":"events","link":"#events","children":[]},{"level":2,"title":"错误处理","slug":"error-handling","link":"#error-handling","children":[]},{"level":2,"title":"和其他组件结合","slug":"combining-with-other-components","link":"#combining-with-other-components","children":[]},{"level":2,"title":"嵌套使用","slug":"nested-suspense","link":"#nested-suspense","children":[]}],"relativePath":"guide/built-ins/suspense.md","filePath":"guide/built-ins/suspense.md"}'),p={name:"guide/built-ins/suspense.md"};function o(t,s,c,r,E,i){return l(),a("div",null,s[0]||(s[0]=[e(`<h1 id="suspense" tabindex="-1">Suspense <a class="header-anchor" href="#suspense" aria-label="Permalink to &quot;Suspense {#suspense}&quot;">​</a></h1><div class="warning custom-block"><p class="custom-block-title">实验性功能</p><p><code>&lt;Suspense&gt;</code> 是一项实验性功能。它不一定会最终成为稳定功能，并且在稳定之前相关 API 也可能会发生变化。</p></div><p><code>&lt;Suspense&gt;</code> 是一个内置组件，用来在组件树中协调对异步依赖的处理。它让我们可以在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态。</p><h2 id="async-dependencies" tabindex="-1">异步依赖 <a class="header-anchor" href="#async-dependencies" aria-label="Permalink to &quot;异步依赖 {#async-dependencies}&quot;">​</a></h2><p>要了解 <code>&lt;Suspense&gt;</code> 所解决的问题和它是如何与异步依赖进行交互的，我们需要想象这样一种组件层级结构：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;Suspense&gt;</span></span>
<span class="line"><span>└─ &lt;Dashboard&gt;</span></span>
<span class="line"><span>   ├─ &lt;Profile&gt;</span></span>
<span class="line"><span>   │  └─ &lt;FriendStatus&gt;（组件有异步的 setup()）</span></span>
<span class="line"><span>   └─ &lt;Content&gt;</span></span>
<span class="line"><span>      ├─ &lt;ActivityFeed&gt; （异步组件）</span></span>
<span class="line"><span>      └─ &lt;Stats&gt;（异步组件）</span></span></code></pre></div><p>在这个组件树中有多个嵌套组件，要渲染出它们，首先得解析一些异步资源。如果没有 <code>&lt;Suspense&gt;</code>，则它们每个都需要处理自己的加载、报错和完成状态。在最坏的情况下，我们可能会在页面上看到三个旋转的加载态，在不同的时间显示出内容。</p><p>有了 <code>&lt;Suspense&gt;</code> 组件后，我们就可以在等待整个多层级组件树中的各个异步依赖获取结果时，在顶层展示出加载中或加载失败的状态。</p><p><code>&lt;Suspense&gt;</code> 可以等待的异步依赖有两种：</p><ol><li><p>带有异步 <code>setup()</code> 钩子的组件。这也包含了使用 <code>&lt;script setup&gt;</code> 时有顶层 <code>await</code> 表达式的组件。</p></li><li><p><a href="/guide/components/async.html">异步组件</a>。</p></li></ol><h3 id="async-setup" tabindex="-1"><code>async setup()</code> <a class="header-anchor" href="#async-setup" aria-label="Permalink to &quot;\`async setup()\` {#async-setup}&quot;">​</a></h3><p>组合式 API 中组件的 <code>setup()</code> 钩子可以是异步的：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  async</span><span style="color:#B392F0;"> setup</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> res</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> posts</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> res.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      posts</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>如果使用 <code>&lt;script setup&gt;</code>，那么顶层 <code>await</code> 表达式会自动让该组件成为一个异步依赖：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#B392F0;"> setup</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> res</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> posts</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> res.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  {{ posts }}</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="async-components" tabindex="-1">异步组件 <a class="header-anchor" href="#async-components" aria-label="Permalink to &quot;异步组件 {#async-components}&quot;">​</a></h3><p>异步组件默认就是<strong>“suspensible”</strong>的。这意味着如果组件关系链上有一个 <code>&lt;Suspense&gt;</code>，那么这个异步组件就会被当作这个 <code>&lt;Suspense&gt;</code> 的一个异步依赖。在这种情况下，加载状态是由 <code>&lt;Suspense&gt;</code> 控制，而该组件自己的加载、报错、延时和超时等选项都将被忽略。</p><p>异步组件也可以通过在选项中指定 <code>suspensible: false</code> 表明不用 <code>Suspense</code> 控制，并让组件始终自己控制其加载状态。</p><h2 id="loading-state" tabindex="-1">加载中状态 <a class="header-anchor" href="#loading-state" aria-label="Permalink to &quot;加载中状态 {#loading-state}&quot;">​</a></h2><p><code>&lt;Suspense&gt;</code> 组件有两个插槽：<code>#default</code> 和 <code>#fallback</code>。两个插槽都只允许<strong>一个</strong>直接子节点。在可能的时候都将显示默认插槽中的节点。否则将显示后备插槽中的节点。</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">Suspense</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">  &lt;!-- 具有深层异步依赖的组件 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#79B8FF;">Dashboard</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  &lt;!-- 在 #fallback 插槽中显示 “正在加载中” --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;"> #</span><span style="color:#B392F0;">fallback</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    Loading...</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#79B8FF;">Suspense</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>在初始渲染时，<code>&lt;Suspense&gt;</code> 将在内存中渲染其默认的插槽内容。如果在这个过程中遇到任何异步依赖，则会进入<strong>挂起</strong>状态。在挂起状态期间，展示的是后备内容。当所有遇到的异步依赖都完成后，<code>&lt;Suspense&gt;</code> 会进入<strong>完成</strong>状态，并将展示出默认插槽的内容。</p><p>如果在初次渲染时没有遇到异步依赖，<code>&lt;Suspense&gt;</code> 会直接进入完成状态。</p><p>进入完成状态后，只有当默认插槽的根节点被替换时，<code>&lt;Suspense&gt;</code> 才会回到挂起状态。组件树中新的更深层次的异步依赖<strong>不会</strong>造成 <code>&lt;Suspense&gt;</code> 回退到挂起状态。</p><p>发生回退时，后备内容不会立即展示出来。相反，<code>&lt;Suspense&gt;</code> 在等待新内容和异步依赖完成时，会展示之前 <code>#default</code> 插槽的内容。这个行为可以通过一个 <code>timeout</code> prop 进行配置：在等待渲染新内容耗时超过 <code>timeout</code> 之后，<code>&lt;Suspense&gt;</code> 将会切换为展示后备内容。若 <code>timeout</code> 值为 <code>0</code> 将导致在替换默认内容时立即显示后备内容。</p><h2 id="events" tabindex="-1">事件 <a class="header-anchor" href="#events" aria-label="Permalink to &quot;事件 {#events}&quot;">​</a></h2><p><code>&lt;Suspense&gt;</code> 组件会触发三个事件：<code>pending</code>、<code>resolve</code> 和 <code>fallback</code>。<code>pending</code> 事件是在进入挂起状态时触发。<code>resolve</code> 事件是在 <code>default</code> 插槽完成获取新内容时触发。<code>fallback</code> 事件则是在 <code>fallback</code> 插槽的内容显示时触发。</p><p>例如，可以使用这些事件在加载新组件时在之前的 DOM 最上层显示一个加载指示器。</p><h2 id="error-handling" tabindex="-1">错误处理 <a class="header-anchor" href="#error-handling" aria-label="Permalink to &quot;错误处理 {#error-handling}&quot;">​</a></h2><p><code>&lt;Suspense&gt;</code> 组件自身目前还不提供错误处理，不过你可以使用 <a href="/api/options-lifecycle.html#errorcaptured"><code>errorCaptured</code></a> 选项或者 <a href="/api/composition-api-lifecycle.html#onerrorcaptured"><code>onErrorCaptured()</code></a> 钩子，在使用到 <code>&lt;Suspense&gt;</code> 的父组件中捕获和处理异步错误。</p><h2 id="combining-with-other-components" tabindex="-1">和其他组件结合 <a class="header-anchor" href="#combining-with-other-components" aria-label="Permalink to &quot;和其他组件结合 {#combining-with-other-components}&quot;">​</a></h2><p>我们常常会将 <code>&lt;Suspense&gt;</code> 和 <a href="./transition.html"><code>&lt;Transition&gt;</code></a>、<a href="./keep-alive.html"><code>&lt;KeepAlive&gt;</code></a> 等组件结合。要保证这些组件都能正常工作，嵌套的顺序非常重要。</p><p>另外，这些组件都通常与 <a href="https://router.vuejs.org/zh/" target="_blank" rel="noreferrer">Vue Router</a> 中的 <code>&lt;RouterView&gt;</code> 组件结合使用。</p><p>下面的示例展示了如何嵌套这些组件，使它们都能按照预期的方式运行。若想组合得更简单，你也可以删除一些你不需要的组件：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">RouterView</span><span style="color:#B392F0;"> v-slot</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">{ Component }</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">template</span><span style="color:#B392F0;"> v-if</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">Component</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#79B8FF;">Transition</span><span style="color:#B392F0;"> mode</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;out-in&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;</span><span style="color:#79B8FF;">KeepAlive</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        &lt;</span><span style="color:#79B8FF;">Suspense</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">          &lt;!-- 主要内容 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">          &lt;</span><span style="color:#85E89D;">component</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">is</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">Component</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">component</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">          &lt;!-- 加载中状态 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">          &lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;"> #</span><span style="color:#B392F0;">fallback</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">            正在加载...</span></span>
<span class="line"><span style="color:#E1E4E8;">          &lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        &lt;/</span><span style="color:#79B8FF;">Suspense</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;/</span><span style="color:#79B8FF;">KeepAlive</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;/</span><span style="color:#79B8FF;">Transition</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#79B8FF;">RouterView</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>Vue Router 使用动态导入对<a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noreferrer">懒加载组件</a>进行了内置支持。这些与异步组件不同，目前他们不会触发 <code>&lt;Suspense&gt;</code>。但是，它们仍然可以有异步组件作为后代，这些组件可以照常触发 <code>&lt;Suspense&gt;</code>。</p><h2 id="nested-suspense" tabindex="-1">嵌套使用 <a class="header-anchor" href="#nested-suspense" aria-label="Permalink to &quot;嵌套使用 {#nested-suspense}&quot;">​</a></h2><ul><li>仅在 3.3+ 支持</li></ul><p>当我们有多个类似于下方的异步组件 (常见于嵌套或基于布局的路由) 时：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">Suspense</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">component</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">is</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">DynamicAsyncOuter</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">component</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">is</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">DynamicAsyncInner</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#85E89D;">component</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#79B8FF;">Suspense</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p><code>&lt;Suspense&gt;</code> 创建了一个边界，它将如预期的那样解析树下的所有异步组件。然而，当我们更改 <code>DynamicAsyncOuter</code> 时，<code>&lt;Suspense&gt;</code> 会正确地等待它，但当我们更改 <code>DynamicAsyncInner</code> 时，嵌套的 <code>DynamicAsyncInner</code> 会呈现为一个空节点，直到它被解析为止 (而不是之前的节点或回退插槽)。</p><p>为了解决这个问题，我们可以使用嵌套的方法来处理嵌套组件的补丁，就像这样：</p><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">Suspense</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">component</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">is</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">DynamicAsyncOuter</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#79B8FF;">Suspense</span><span style="color:#B392F0;"> suspensible</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#6A737D;">&lt;!-- 像这样 --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;</span><span style="color:#85E89D;">component</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">is</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">DynamicAsyncInner</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;/</span><span style="color:#79B8FF;">Suspense</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#85E89D;">component</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#79B8FF;">Suspense</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>如果你不设置 <code>suspensible</code> 属性，内部的 <code>&lt;Suspense&gt;</code> 将被父级 <code>&lt;Suspense&gt;</code> 视为同步组件。这意味着它将会有自己的回退插槽，如果两个 <code>Dynamic</code> 组件同时被修改，则当子 <code>&lt;Suspense&gt;</code> 加载其自己的依赖关系树时，可能会出现空节点和多个修补周期，这可能不是理想情况。设置后，所有异步依赖项处理都会交给父级 <code>&lt;Suspense&gt;</code> (包括发出的事件)，而内部 <code>&lt;Suspense&gt;</code> 仅充当依赖项解析和修补的另一个边界。</p><hr><p><strong>参考</strong></p><ul><li><a href="/api/built-in-components.html#suspense"><code>&lt;Suspense&gt;</code> API 参考</a></li></ul>`,47)]))}const u=n(p,[["render",o]]);export{y as __pageData,u as default};
