import{_ as a,c as n,b as l,o}from"./chunks/framework.B2oIMGqn.js";const d=JSON.parse('{"title":"响应式 API：进阶","description":"","frontmatter":{},"headers":[{"level":2,"title":"shallowRef()","slug":"shallowref","link":"#shallowref","children":[]},{"level":2,"title":"triggerRef()","slug":"triggerref","link":"#triggerref","children":[]},{"level":2,"title":"customRef()","slug":"customref","link":"#customref","children":[]},{"level":2,"title":"shallowReactive()","slug":"shallowreactive","link":"#shallowreactive","children":[]},{"level":2,"title":"shallowReadonly()","slug":"shallowreadonly","link":"#shallowreadonly","children":[]},{"level":2,"title":"toRaw()","slug":"toraw","link":"#toraw","children":[]},{"level":2,"title":"markRaw()","slug":"markraw","link":"#markraw","children":[]},{"level":2,"title":"effectScope()","slug":"effectscope","link":"#effectscope","children":[]},{"level":2,"title":"getCurrentScope()","slug":"getcurrentscope","link":"#getcurrentscope","children":[]},{"level":2,"title":"onScopeDispose()","slug":"onscopedispose","link":"#onscopedispose","children":[]}],"relativePath":"api/reactivity-advanced.md","filePath":"api/reactivity-advanced.md"}'),p={name:"api/reactivity-advanced.md"};function e(t,s,c,r,i,y){return o(),n("div",null,s[0]||(s[0]=[l(`<h1 id="reactivity-api-advanced" tabindex="-1">响应式 API：进阶 <a class="header-anchor" href="#reactivity-api-advanced" aria-label="Permalink to &quot;响应式 API：进阶 {#reactivity-api-advanced}&quot;">​</a></h1><h2 id="shallowref" tabindex="-1">shallowRef() <a class="header-anchor" href="#shallowref" aria-label="Permalink to &quot;shallowRef() {#shallowref}&quot;">​</a></h2><p><a href="./reactivity-core.html#ref"><code>ref()</code></a> 的浅层作用形式。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> shallowRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> ShallowRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">interface</span><span style="color:#B392F0;"> ShallowRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#FFAB70;">  value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>详细信息</strong></p><p>和 <code>ref()</code> 不同，浅层 ref 的内部值将会原样存储和暴露，并且不会被深层递归地转为响应式。只有对 <code>.value</code> 的访问是响应式的。</p><p><code>shallowRef()</code> 常常用于对大型数据结构的性能优化或是与外部的状态管理系统集成。</p></li><li><p><strong>示例</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> state</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> shallowRef</span><span style="color:#E1E4E8;">({ count: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> })</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 不会触发更改</span></span>
<span class="line"><span style="color:#E1E4E8;">state.value.count </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 2</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 会触发更改</span></span>
<span class="line"><span style="color:#E1E4E8;">state.value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { count: </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> }</span></span></code></pre></div></li><li><p><strong>参考</strong></p><ul><li><a href="/guide/best-practices/performance.html#reduce-reactivity-overhead-for-large-immutable-structures">指南 - 减少大型不可变结构的响应性开销</a></li><li><a href="/guide/extras/reactivity-in-depth.html#integration-with-external-state-systems">指南 - 与其他状态系统集成</a></li></ul></li></ul><h2 id="triggerref" tabindex="-1">triggerRef() <a class="header-anchor" href="#triggerref" aria-label="Permalink to &quot;triggerRef() {#triggerref}&quot;">​</a></h2><p>强制触发依赖于一个<a href="#shallowref">浅层 ref</a> 的副作用，这通常在对浅引用的内部值进行深度变更后使用。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> triggerRef</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">ref</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> ShallowRef</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> void</span></span></code></pre></div></li><li><p><strong>示例</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> shallow</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> shallowRef</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  greet: </span><span style="color:#9ECBFF;">&#39;Hello, world&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 触发该副作用第一次应该会打印 &quot;Hello, world&quot;</span></span>
<span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(shallow.value.greet)</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 这次变更不应触发副作用，因为这个 ref 是浅层的</span></span>
<span class="line"><span style="color:#E1E4E8;">shallow.value.greet </span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;"> &#39;Hello, universe&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 打印 &quot;Hello, universe&quot;</span></span>
<span class="line"><span style="color:#B392F0;">triggerRef</span><span style="color:#E1E4E8;">(shallow)</span></span></code></pre></div></li></ul><h2 id="customref" tabindex="-1">customRef() <a class="header-anchor" href="#customref" aria-label="Permalink to &quot;customRef() {#customref}&quot;">​</a></h2><p>创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> customRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">factory</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> CustomRefFactory</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> CustomRefFactory</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#B392F0;">  track</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#B392F0;">  trigger</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#B392F0;">  get</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> T</span></span>
<span class="line"><span style="color:#B392F0;">  set</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>详细信息</strong></p><p><code>customRef()</code> 预期接收一个工厂函数作为参数，这个工厂函数接受 <code>track</code> 和 <code>trigger</code> 两个函数作为参数，并返回一个带有 <code>get</code> 和 <code>set</code> 方法的对象。</p><p>一般来说，<code>track()</code> 应该在 <code>get()</code> 方法中调用，而 <code>trigger()</code> 应该在 <code>set()</code> 中调用。然而事实上，你对何时调用、是否应该调用他们有完全的控制权。</p></li><li><p><strong>示例</strong></p><p>创建一个防抖 ref，即只在最近一次 set 调用后的一段固定间隔后再调用：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { customRef } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> useDebouncedRef</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">delay</span><span style="color:#F97583;"> =</span><span style="color:#79B8FF;"> 200</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  let</span><span style="color:#E1E4E8;"> timeout</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#B392F0;"> customRef</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">track</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">trigger</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#B392F0;">      get</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#B392F0;">        track</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> value</span></span>
<span class="line"><span style="color:#E1E4E8;">      },</span></span>
<span class="line"><span style="color:#B392F0;">      set</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">newValue</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#B392F0;">        clearTimeout</span><span style="color:#E1E4E8;">(timeout)</span></span>
<span class="line"><span style="color:#E1E4E8;">        timeout </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">          value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newValue</span></span>
<span class="line"><span style="color:#B392F0;">          trigger</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">        }, delay)</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>在组件中使用：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#B392F0;"> setup</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { useDebouncedRef } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;./debouncedRef&#39;</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> text</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> useDebouncedRef</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;hello&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">input</span><span style="color:#B392F0;"> v-model</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;text&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p><a href="https://play.vuejs.org/#eNplUkFugzAQ/MqKC1SiIekxIpEq9QVV1BMXCguhBdsyaxqE/PcuGAhNfYGd3Z0ZDwzeq1K7zqB39OI205UiaJGMOieiapTUBAOYFt/wUxqRYf6OBVgotGzA30X5Bt59tX4iMilaAsIbwelxMfCvWNfSD+Gw3++fEhFHTpLFuCBsVJ0ScgUQjw6Az+VatY5PiroHo3IeaeHANlkrh7Qg1NBL43cILUmlMAfqVSXK40QUOSYmHAZHZO0KVkIZgu65kTnWp8Qb+4kHEXfjaDXkhd7DTTmuNZ7MsGyzDYbz5CgSgbdppOBFqqT4l0eX1gZDYOm057heOBQYRl81coZVg9LQWGr+IlrchYKAdJp9h0C6KkvUT3A6u8V1dq4ASqRgZnVnWg04/QWYNyYzC2rD5Y3/hkDgz8fY/cOT1ZjqizMZzGY3rDPC12KGZYyd3J26M8ny1KKx7c3X25q1c1wrZN3L9LCMWs/+AmeG6xI=" target="_blank" rel="noreferrer">在演练场中尝试一下</a></p><div class="warning custom-block"><p class="custom-block-title">谨慎使用</p><p>当使用 customRef 时，我们应该谨慎对待其 getter 的返回值，尤其是在每次运行 getter 时都生成新对象数据类型的情况下。当这样的 customRef 作为 prop 传递时，将影响父组件和子组件之间的关系。</p><p>父组件的渲染函数可能会被其他的响应式状态变化触发。在重新渲染过程中，我们会重新评估 customRef 的值，并返回一个新的对象数据类型作为子组件的 prop。这个 prop 会与其上一个值进行比较，由于两者不同，子组件中 customRef 的响应式依赖将被触发。与此同时，因为没有调用 customRef 的 setter，父组件中的响应式依赖不会运行。</p><p><a href="https://play.vuejs.org/#eNqFVEtP3DAQ/itTS9Vm1ZCt1J6WBZUiDvTQIsoNcwiOkzU4tmU7+9Aq/71jO1mCWuhlN/PyfPP45kAujCk2HSdLsnLMCuPBcd+Zc6pEa7T1cADWOa/bW17nYMPPtvRsDT3UVrcww+DZ0flStybpKSkWQQqPU0IVVUwr58FYvdvDWXgpu6ek1pqSHL0fS0vJw/z0xbN1jUPHY/Ys87Zkzzl4K5qG2zmcnUN2oAqg4T6bQ/wENKNXNk+CxWKsSlmLTSk7XlhedYxnWclYDiK+MkQCoK4wnVtnIiBJuuEJNA2qPof7hzkEoc8DXgg9yzYTBBFgNr4xyY4FbaK2p6qfI0iqFgtgulOe27HyQRy69Dk1JXY9C03JIeQ6wg4xWvJCqFpnlNytOcyC2wzYulQNr0Ao+Mhw0KnTTEttl/CIaIJiMz8NGBHFtYetVrPwa58/IL48Zag4N0ssquNYLYBoW16J0vOkC3VQtVqk7cG9QcHz1kj0QAlgVYkNMFk6d0bJ1pbGYKUkmtD42HmvFfi94WhOEiXwjUnBnlEz9OLTJwy5qCo44D4O7en71SIFjI/F9VuG4jEy/GHQKq5hQrJAKOc4uNVighBF5/cygS0GgOMoK+HQb7+EWvLdMM7weVIJy5kXWi0Rj+xaNRhLKRp1IvB9hxYegA6WJ1xkUe9PcF4e9a+suA3YwYiC5MQ79KlFUzw5rZCZEUtoRWuE5PaXCXmxtuWIkpJSSr39EXXHQcWYNWfP/9A/uV3QUXJjueN2E1ZhtPnSIqGS+er3T77D76Ox1VUn0fsd4y3HfewCxuT2vVMVwp74RbTX8WQI1dy5qx12xI1Fpa1K5AreeEHCCN8q/QXul+LrSC3s4nh93jltkVPDIYt5KJkcIKStCReo4rVQ/CZI6dyEzToCCJu7hAtry/1QH/qXncQB400KJwqPxZHxEyona0xS/E3rt1m9Ld1rZl+uhaxecRtP3EjtgddCyimtXyj9H/Ii3eId7uOGTkyk/wOEbQ9h" target="_blank" rel="noreferrer">在演练场中尝试一下</a></p></div></li></ul><h2 id="shallowreactive" tabindex="-1">shallowReactive() <a class="header-anchor" href="#shallowreactive" aria-label="Permalink to &quot;shallowReactive() {#shallowreactive}&quot;">​</a></h2><p><a href="./reactivity-core.html#reactive"><code>reactive()</code></a> 的浅层作用形式。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> shallowReactive</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#F97583;"> extends</span><span style="color:#79B8FF;"> object</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">target</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span></code></pre></div></li><li><p><strong>详细信息</strong></p><p>和 <code>reactive()</code> 不同，这里没有深层级的转换：一个浅层响应式对象里只有根级别的属性是响应式的。属性的值会被原样存储和暴露，这也意味着值为 ref 的属性<strong>不会</strong>被自动解包了。</p><div class="warning custom-block"><p class="custom-block-title">谨慎使用</p><p>浅层数据结构应该只用于组件中的根级状态。请避免将其嵌套在深层次的响应式对象中，因为它创建的树具有不一致的响应行为，这可能很难理解和调试。</p></div></li><li><p><strong>示例</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> state</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> shallowReactive</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  foo: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  nested: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    bar: </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 更改状态自身的属性是响应式的</span></span>
<span class="line"><span style="color:#E1E4E8;">state.foo</span><span style="color:#F97583;">++</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// ...但下层嵌套对象不会被转为响应式</span></span>
<span class="line"><span style="color:#B392F0;">isReactive</span><span style="color:#E1E4E8;">(state.nested) </span><span style="color:#6A737D;">// false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 不是响应式的</span></span>
<span class="line"><span style="color:#E1E4E8;">state.nested.bar</span><span style="color:#F97583;">++</span></span></code></pre></div></li></ul><h2 id="shallowreadonly" tabindex="-1">shallowReadonly() <a class="header-anchor" href="#shallowreadonly" aria-label="Permalink to &quot;shallowReadonly() {#shallowreadonly}&quot;">​</a></h2><p><a href="./reactivity-core.html#readonly"><code>readonly()</code></a> 的浅层作用形式</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> shallowReadonly</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#F97583;"> extends</span><span style="color:#79B8FF;"> object</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">target</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Readonly</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>详细信息</strong></p><p>和 <code>readonly()</code> 不同，这里没有深层级的转换：只有根层级的属性变为了只读。属性的值都会被原样存储和暴露，这也意味着值为 ref 的属性<strong>不会</strong>被自动解包了。</p><div class="warning custom-block"><p class="custom-block-title">谨慎使用</p><p>浅层数据结构应该只用于组件中的根级状态。请避免将其嵌套在深层次的响应式对象中，因为它创建的树具有不一致的响应行为，这可能很难理解和调试。</p></div></li><li><p><strong>示例</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> state</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> shallowReadonly</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  foo: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  nested: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    bar: </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 更改状态自身的属性会失败</span></span>
<span class="line"><span style="color:#E1E4E8;">state.foo</span><span style="color:#F97583;">++</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// ...但可以更改下层嵌套对象</span></span>
<span class="line"><span style="color:#B392F0;">isReadonly</span><span style="color:#E1E4E8;">(state.nested) </span><span style="color:#6A737D;">// false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 这是可以通过的</span></span>
<span class="line"><span style="color:#E1E4E8;">state.nested.bar</span><span style="color:#F97583;">++</span></span></code></pre></div></li></ul><h2 id="toraw" tabindex="-1">toRaw() <a class="header-anchor" href="#toraw" aria-label="Permalink to &quot;toRaw() {#toraw}&quot;">​</a></h2><p>根据一个 Vue 创建的代理返回其原始对象。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> toRaw</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">proxy</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span></code></pre></div></li><li><p><strong>详细信息</strong></p><p><code>toRaw()</code> 可以返回由 <a href="./reactivity-core.html#reactive"><code>reactive()</code></a>、<a href="./reactivity-core.html#readonly"><code>readonly()</code></a>、<a href="#shallowreactive"><code>shallowReactive()</code></a> 或者 <a href="#shallowreadonly"><code>shallowReadonly()</code></a> 创建的代理对应的原始对象。</p><p>这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。</p></li><li><p><strong>示例</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> foo</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> {}</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> reactiveFoo</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">(foo)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">toRaw</span><span style="color:#E1E4E8;">(reactiveFoo) </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> foo) </span><span style="color:#6A737D;">// true</span></span></code></pre></div></li></ul><h2 id="markraw" tabindex="-1">markRaw() <a class="header-anchor" href="#markraw" aria-label="Permalink to &quot;markRaw() {#markraw}&quot;">​</a></h2><p>将一个对象标记为不可被转为代理。返回该对象本身。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> markRaw</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#F97583;"> extends</span><span style="color:#79B8FF;"> object</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span></code></pre></div></li><li><p><strong>示例</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> foo</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> markRaw</span><span style="color:#E1E4E8;">({})</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">isReactive</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">reactive</span><span style="color:#E1E4E8;">(foo))) </span><span style="color:#6A737D;">// false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 也适用于嵌套在其他响应性对象</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> bar</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({ foo })</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">isReactive</span><span style="color:#E1E4E8;">(bar.foo)) </span><span style="color:#6A737D;">// false</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">谨慎使用</p><p><code>markRaw()</code> 和类似 <code>shallowReactive()</code> 这样的浅层式 API 使你可以有选择地避开默认的深度响应/只读转换，并在状态关系谱中嵌入原始的、非代理的对象。它们可能出于各种各样的原因被使用：</p><ul><li><p>有些值不应该是响应式的，例如复杂的第三方类实例或 Vue 组件对象。</p></li><li><p>当呈现带有不可变数据源的大型列表时，跳过代理转换可以提高性能。</p></li></ul><p>这应该是一种进阶需求，因为只在根层能访问到原始值，所以如果把一个嵌套的、没有标记的原始对象设置成一个响应式对象，然后再次访问它，你获取到的是代理的版本。这可能会导致<strong>对象身份风险</strong>，即执行一个依赖于对象身份的操作，但却同时使用了同一对象的原始版本和代理版本：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> foo</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> markRaw</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  nested: {}</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> bar</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#6A737D;">  // 尽管 \`foo\` 被标记为了原始对象，但 foo.nested 却没有</span></span>
<span class="line"><span style="color:#E1E4E8;">  nested: foo.nested</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(foo.nested </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> bar.nested) </span><span style="color:#6A737D;">// false</span></span></code></pre></div><p>识别风险一般是很罕见的。然而，要正确使用这些 API，同时安全地避免这样的风险，需要你对响应性系统的工作方式有充分的了解。</p></div></li></ul><h2 id="effectscope" tabindex="-1">effectScope() <a class="header-anchor" href="#effectscope" aria-label="Permalink to &quot;effectScope() {#effectscope}&quot;">​</a></h2><p>创建一个 effect 作用域，可以捕获其中所创建的响应式副作用 (即计算属性和侦听器)，这样捕获到的副作用可以一起处理。对于该 API 的使用细节，请查阅对应的 <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md" target="_blank" rel="noreferrer">RFC</a>。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> effectScope</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">detached</span><span style="color:#F97583;">?:</span><span style="color:#79B8FF;"> boolean</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> EffectScope</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">interface</span><span style="color:#B392F0;"> EffectScope</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#B392F0;">  run</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#B392F0;">fn</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> |</span><span style="color:#79B8FF;"> undefined</span><span style="color:#6A737D;"> // 如果作用域不活跃就为 undefined</span></span>
<span class="line"><span style="color:#B392F0;">  stop</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> void</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>示例</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> scope</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> effectScope</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">scope.</span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> doubled</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> computed</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> counter.value </span><span style="color:#F97583;">*</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">  watch</span><span style="color:#E1E4E8;">(doubled, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(doubled.value))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">  watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Count: &#39;</span><span style="color:#E1E4E8;">, doubled.value))</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 处理掉当前作用域内的所有 effect</span></span>
<span class="line"><span style="color:#E1E4E8;">scope.</span><span style="color:#B392F0;">stop</span><span style="color:#E1E4E8;">()</span></span></code></pre></div></li></ul><h2 id="getcurrentscope" tabindex="-1">getCurrentScope() <a class="header-anchor" href="#getcurrentscope" aria-label="Permalink to &quot;getCurrentScope() {#getcurrentscope}&quot;">​</a></h2><p>如果有的话，返回当前活跃的 <a href="#effectscope">effect 作用域</a>。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> getCurrentScope</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> EffectScope</span><span style="color:#F97583;"> |</span><span style="color:#79B8FF;"> undefined</span></span></code></pre></div></li></ul><h2 id="onscopedispose" tabindex="-1">onScopeDispose() <a class="header-anchor" href="#onscopedispose" aria-label="Permalink to &quot;onScopeDispose() {#onscopedispose}&quot;">​</a></h2><p>在当前活跃的 <a href="#effectscope">effect 作用域</a>上注册一个处理回调函数。当相关的 effect 作用域停止时会调用这个回调函数。</p><p>这个方法可以作为可复用的组合式函数中 <code>onUnmounted</code> 的替代品，它并不与组件耦合，因为每一个 Vue 组件的 <code>setup()</code> 函数也是在一个 effect 作用域中调用的。</p><p>如果在没有活跃的 effect 作用域的情况下调用此函数，将会抛出警告。在 3.5+ 版本中，可以通过将第二个参数设为 <code>true</code> 来消除此警告。</p><ul><li><p><strong>类型</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> onScopeDispose</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">fn</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">failSilently</span><span style="color:#F97583;">?:</span><span style="color:#79B8FF;"> boolean</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> void</span></span></code></pre></div></li></ul>`,33)]))}const F=a(p,[["render",e]]);export{d as __pageData,F as default};
